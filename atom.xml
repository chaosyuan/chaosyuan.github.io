<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>袁伟的技术博客</title>
  <subtitle>千里之行始于足下</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chaosyuan.github.io/"/>
  <updated>2016-08-19T01:59:20.000Z</updated>
  <id>http://chaosyuan.github.io/</id>
  
  <author>
    <name>袁伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 视图控制器转场</title>
    <link href="http://chaosyuan.github.io/2016/07/01/iOS-%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E8%BD%AC%E5%9C%BA/"/>
    <id>http://chaosyuan.github.io/2016/07/01/iOS-视图控制器转场/</id>
    <published>2016-07-01T08:56:35.000Z</published>
    <updated>2016-08-19T01:59:20.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>最近闲暇之余,仔细研究了下iOS 视图控制器转场动画。详细考<a href="https://onevcat.com/2013/10/vc-transition-in-ios7/" target="_blank" rel="external">onevcat</a> 及 <a href="http://www.jianshu.com/p/9333c5f983de" target="_blank" rel="external">seedante</a>，结合自己的思考和实践。把相关学习心得记录一下。</p>
<h5 id="转场"><a href="#转场" class="headerlink" title="转场"></a>转场</h5><p>在 storyboard 中,每个 View Controller 都是一个 Scene，所谓转场（View Controller Transition） 便是从一个 Scene 转换到另外一个 Scene。</p>
<p>转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现，基于此进行动画,动画的方式非常多.</p>
<a id="more"></a>
<h5 id="转场方式"><a href="#转场方式" class="headerlink" title="转场方式"></a>转场方式</h5><p>官方目前支持4种转场方式：</p>
<blockquote>
<ol>
<li>UINavigationController   push 和 pop</li>
<li>UITabBarController  选择切换 Tab</li>
<li>Modal  presentation 和 dismissal，视图控制器的模态显示和消失</li>
<li>UICollectionViewController  CollectionViewController 与 UINavigationController 结合的转场方式</li>
</ol>
</blockquote>
<h5 id="转场API"><a href="#转场API" class="headerlink" title="转场API"></a>转场API</h5><p>iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，使其可以非常灵活的使用。转场协议由5种协议组成，实际中只需要使用其中的两个或三个便能实现绝大部分的转场动画。</p>
<blockquote>
<ol>
<li>动画控制器 (Animation Controllers) 遵守 <a href="https://developer.apple.com/reference/uikit/uiviewcontrolleranimatedtransitioning?language=objc" target="_blank" rel="external">UIViewControllerAnimatedTransitioning</a> 协议，并且负责实际执行动画。</li>
<li>交互控制器 (Interaction Controllers) 通过遵守 <a href="https://developer.apple.com/reference/uikit/uiviewcontrollercontexttransitioning?language=objc" target="_blank" rel="external">UIViewControllerInteractiveTransitioning</a> 协议,来控制可交互式(手势或重力感应…)动画转场，大多都是使用它的一个子类UIPercentDrivenInteractiveTransition来更简单的实现手势交互动画。</li>
<li>转场代理 (Transitioning Delegates) 根据不同的转场类型，提供需要的动画控制器和交互控制器。有3种转场代理：<br><strong><a href="https://developer.apple.com/reference/uikit/uinavigationcontrollerdelegate?language=objc" target="_blank" rel="external">UINavigationControllerDelegate</a></strong>  –自定义navigationController转场动画的时候<br><strong><a href="https://developer.apple.com/reference/uikit/uitabbarcontrollerdelegate?language=objc" target="_blank" rel="external">UITabBarControllerDelegate</a></strong> –自定义tabbarController转场动画的时候<br><strong><a href="https://developer.apple.com/reference/uikit/uiviewcontrollertransitioningdelegate?language=objc" target="_blank" rel="external">UIViewControllerTransitioningDelegate</a></strong>  –自定义present/dismiss的时候</li>
<li>转场上下文 (Transitioning Context) 提供转场中需要的数据，比如在转场过程中所参与的视图控制器和视图的相关属性。 转场上下文对象遵守  <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerContextTransitioning_protocol/index.html#//apple_ref/occ/intfm/UIViewControllerContextTransitioning/cancelInteractiveTransition" target="_blank" rel="external">UIViewControllerContextTransitioning</a> 协议，并且这是由系统负责生成和提供的。</li>
<li>转场协调器(Transition Coordinators) 可以在运行转场动画时，并行的运行其他动画。转场协调器遵守 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewControllerTransitionCoordinator_Protocol/index.html#//apple_ref/doc/uid/TP40013295" target="_blank" rel="external">UIViewControllerTransitionCoordinator</a> 协议</li>
</ol>
</blockquote>
<p>要实现一个最低限度的转场动画，必须要满足三个条件:</p>
<blockquote>
<ol>
<li>动画控制器</li>
<li>转场代理</li>
<li>转场上下文(转场上下文是由系统提供的)</li>
</ol>
</blockquote>
<p>当实现交互转场时，还需要提供交互控制器，也有系统封装的类（UIPercentDrivenInteractiveTransition）可供可直接使用。</p>
<p>自定义转场的就是提供转场代理，并告诉系统使用我们提供的代理执行转场,如果没有提供转场代理, 那么将会使用系统默认的。</p>
<p>转场有<strong>非可交互式</strong>和<strong>可交互式</strong>两种方式.</p>
<h4 id="非交互转场"><a href="#非交互转场" class="headerlink" title="非交互转场"></a>非交互转场</h4><p><strong>动画控制器协议</strong><br>动画控制器负责添加视图以及执行动画，遵守UIViewControllerAnimatedTransitioning协议,共有3个协议方法，前2个为required.后一个为optional<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//返回动画执行的时间</div><div class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div><div class="line">//最核心方法 执行动画的地方</div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div><div class="line">//转场动画结束后调用，执行一些收尾工作</div><div class="line">- (void)animationEnded:(BOOL) transitionCompleted;</div></pre></td></tr></table></figure></p>
<p>从第二个协议方法中，通过转场上下文（transitionContext）可以获取到源控制器和目标控制器以及视图的相关属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//获取参与转场的视图控制器</div><div class="line">- (void)animateTransition:(nonnull id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</div><div class="line">    FirstViewController *fromVC = (FirstViewController *)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">    SecondViewController *toVC   = (SecondViewController *)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">    </div><div class="line">    //获取转场发生的容器</div><div class="line">    UIView *containerView    = [transitionContext containerView];</div><div class="line">    //获取动画时间</div><div class="line">    NSTimeInterval duration = [self transitionDuration:transitionContext];</div><div class="line">      //iOS8之后使用</div><div class="line">    UIView *fromView = [transitionContext viewForKey:UITransitionContextFromViewKey];</div><div class="line">    UIView *toView = [transitionContext viewForKey:UITransitionContextToViewKey];</div><div class="line">    </div><div class="line">     toVC.view.frame = [transitionContext finalFrameForViewController:toVC];</div><div class="line">     //使用initialFrameForViewController 和 finalFrameForViewController 获取过渡开始和结束时每个 ViewController 的 frame</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/collectionViewScale.gif" alt="enter image description here"></p>
<p>说一下iOS—UIView中坐标转化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//将rect由rect所在视图转换到目标视图view中,返回在目标视图view中的rect</div><div class="line">- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;</div><div class="line">//将rect从view转换到当前视图中，返回在当前视图中的rect</div><div class="line">- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    [UIView animateWithDuration:duration animations:^&#123;</div><div class="line">    </div><div class="line">    toVC.view.alpha  = 1.0f;</div><div class="line">    CGRect frame = [containerView convertRect:toVC.imageView.frame fromView:toVC.view];</div><div class="line">    cellImageSnapshot.frame = frame;</div><div class="line">    </div><div class="line">&#125; completion:^(BOOL finished) &#123;</div><div class="line">    </div><div class="line">    toVC.imageView.hidden = NO;</div><div class="line">    cell.hidden = NO;</div><div class="line">    [cellImageSnapshot removeFromSuperview];</div><div class="line">    //转场完成</div><div class="line">    [transitionContext completeTransition:!transitionContext.transitionWasCancelled];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>转场操作是可逆的。</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/collectionViewPushPop.gif" alt="enter image description here"></p>
<h5 id="Modal-转场"><a href="#Modal-转场" class="headerlink" title="Modal 转场"></a>Modal 转场</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//返回一个管理prenent动画控制器</div><div class="line"> - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;</div><div class="line"> //返回一个管理pop动画控制器</div><div class="line"> - (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;</div><div class="line"> //返回一个管理prenent手势过渡的交互控制器</div><div class="line"> - (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;</div><div class="line"> //返回一个管理pop动画过渡的交互控制器</div><div class="line"> - (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;</div></pre></td></tr></table></figure>
<p>自定义present/dismiss动画的系统调用过程:</p>
<blockquote>
<ol>
<li>UIKit首先会调用代理的<br>animationControllerForPresentedController:presentingController:<br>sourceController:方法取得自定义的动画对象</li>
<li>UIKit接着调用代理的 interactionControllerForPresentation: 方法看是否支持交互性动画, 如果返回nil表示不支持</li>
<li>如果是不可交互的动画UIKit会调用代理的animateTransition:方法来执行真正的动画</li>
<li>如果是可交互的动画, UIKit会调用代理的startInteractiveTransition:方法开始动画</li>
<li>代理调用completeTransition:结束动画(动画执行完毕后调用这个方法,告诉系统动画执行完毕或者中途取消)</li>
</ol>
</blockquote>
<p>系统已经为 Modal 转场实现了多种弹出风格效果，当 UIViewController 的modalPresentationStyle属性为<strong>UIModalPresentationCustom</strong> 时，就可以定制转场效果，这时modalTransitionStyle(弹出时的动画风格)将会被忽略.</p>
<p>顺带说一下：</p>
<blockquote>
<p><strong><em>presentedViewController</em></strong>：The view controller that is presented by this view controlller(read-only)，被本视图控制器present出来的的视图控制器。[<strong>被呈现</strong>]<br><strong><em>presentingViewController</em></strong>：The view controller that presented this view controller. (read-only)，present出来本视图控制器的视图控制器.[<strong>负责呈现</strong>]</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/9333c5f983de" target="_blank" rel="external">seedante大神</a>特别指出modal转场时，处理的特殊性.在<strong>UIModalPresentationCustom</strong>模式下，presentingView 并不受 containerView 管理，fromView(presentingView) 未被移出视图结构。所以presentation 转场中，不要手动将 fromView(presentingView) 移出其父视图。在 dismissal 转场中不要将 toView(presentingView) 加入 containerView。</p>
<p>在实际测试时发现，确实如此，当在dismiss转场时将 toView(presentingView) 加入 containerView.应用直接黑屏。</p>
<h5 id="UIPresentationController"><a href="#UIPresentationController" class="headerlink" title="UIPresentationController"></a>UIPresentationController</h5><p><em>UIPresentationController</em>是提供高级视图切换的类(iOS8)。配合UIViewControllerTransitioning来实现Modal 转场进行进一步的定制.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//在呈现过渡即将开始的时候被调用的</div><div class="line">public func presentationTransitionWillBegin()</div><div class="line">//在呈现过渡结束时被调用的</div><div class="line">public func presentationTransitionDidEnd(completed: Bool)</div><div class="line">//在退出过渡即将开始的时候被调用的</div><div class="line">public func dismissalTransitionWillBegin()</div><div class="line">//在退出的过渡结束时被调用的</div><div class="line">public func dismissalTransitionDidEnd(completed: Bool)</div></pre></td></tr></table></figure></p>
<p>在 iOS 7 中，Custom 模式的 Modal 转场里，presentingView 不会被移除.但是在 UIPresentationController中，可以通过 <code>public func shouldRemovePresentersView() -&gt; Bool</code>决定 presentingView 是否在 presentation 转场结束后被移除.</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/PresentationControlAnimate.gif" alt="enter image description here"></p>
<h4 id="交互式转场"><a href="#交互式转场" class="headerlink" title="交互式转场"></a>交互式转场</h4><p>交互转场比非交互转场稍微复杂点，满足交互转场需要：转场代理提供交互控制器（一般使用UIPercentDrivenInteractiveTransition来更简单的实现手势交互动画），另外交互控制器必须有动画控制器才能工作。交互控制器还需要交互配合，比如手势或重力感应等等,来驱动整个转场进程。</p>
<p>UIPercentDrivenInteractiveTransition遵守UIViewControllerInteractiveTransitioning协议的一个对象,做为交互控制器。交互过程是由转场对象上下文管理控制的，用下面三个方法控制转场进度的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//更新转场进度 进度值0.f-1.0f</div><div class="line">- (void)updateInteractiveTransition:(CGFloat)percentComplete;</div><div class="line">//取消转场，转场动画从当前状态返回至转场发生前的状态</div><div class="line">- (void)cancelInteractiveTransition;</div><div class="line">//完成转场，转场动画从当前状态继续直到结束</div><div class="line">- (void)finishInteractiveTransition;</div></pre></td></tr></table></figure>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/interativePresent.gif" alt="enter image description here"></p>
<p>使用UIPercentDrivenInteractiveTransition做个全屏返回手势的Demo。这个只是学习实践，并非最佳实践(最佳实践参考<a href="http://www.jianshu.com/p/d39f7d22db6c" target="_blank" rel="external">J_雨</a>或<a href="http://blog.sunnyxx.com/2015/06/07/fullscreen-pop-gesture/" target="_blank" rel="external">FDFullscreenPopGesture</a>)</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/interativefullPushPop.gif" alt="enter image description here"></p>
<p>UIPercentDrivenInteractiveTransition类是一个系统提供的交互控制器。在转场代理的相关方法里提供一个实例就可以了，如果有其他需求的话，可继承重写方法。<a href="https://github.com/ColinEberhardt/VCTransitionsLibrary" target="_blank" rel="external">VCTransitionsLibrary</a>封装好了动画控制器和交互控制器，并支持多种动画。</p>
<p>由于初次实践，如有不正确或者缺漏的地方，还请大家批评指正。最后附上：<a href="https://github.com/chaosyuan/TransitionAnimate" target="_blank" rel="external">Demo地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;最近闲暇之余,仔细研究了下iOS 视图控制器转场动画。详细考&lt;a href=&quot;https://onevcat.com/2013/10/vc-transition-in-ios7/&quot;&gt;onevcat&lt;/a&gt; 及 &lt;a href=&quot;http://www.jianshu.com/p/9333c5f983de&quot;&gt;seedante&lt;/a&gt;，结合自己的思考和实践。把相关学习心得记录一下。&lt;/p&gt;
&lt;h5 id=&quot;转场&quot;&gt;&lt;a href=&quot;#转场&quot; class=&quot;headerlink&quot; title=&quot;转场&quot;&gt;&lt;/a&gt;转场&lt;/h5&gt;&lt;p&gt;在 storyboard 中,每个 View Controller 都是一个 Scene，所谓转场（View Controller Transition） 便是从一个 Scene 转换到另外一个 Scene。&lt;/p&gt;
&lt;p&gt;转场过程中，作为容器的父 VC 维护着多个子 VC，但在视图结构上，只保留一个子 VC 的视图，所以转场的本质是下一场景(子 VC)的视图替换当前场景(子 VC)的视图以及相应的控制器(子 VC)的替换，表现为当前视图消失和下一视图出现，基于此进行动画,动画的方式非常多.&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
      <category term="动画" scheme="http://chaosyuan.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>YYCache源码阅读</title>
    <link href="http://chaosyuan.github.io/2016/05/12/2016-05-12-yycacheyuan-ma-yue-du/"/>
    <id>http://chaosyuan.github.io/2016/05/12/2016-05-12-yycacheyuan-ma-yue-du/</id>
    <published>2016-05-12T13:36:54.000Z</published>
    <updated>2016-08-10T03:06:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在iOS 开发中总会用到各种缓存。通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。<a href="https://github.com/ibireme/YYCache" target="_blank" rel="external">YYCache</a>或许是最好的选择之一。性能上有优势，用法也很简单。在阅读完源码之后，记录一下源码解析笔记。</p>
<h4 id="层级结构"><a href="#层级结构" class="headerlink" title="层级结构"></a>层级结构</h4><p>YYCache是对内存缓存和磁盘缓存的封装。YYMemoryCache为内存缓存，YYDiskCache为磁盘缓存，YYKVStorage为磁盘缓存的底层实现。下面看一下具体的实现细节。</p>
<h4 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h4><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@property (copy, readonly) NSString *name;</div><div class="line"></div><div class="line">// memoryCache为内容缓存  diskCache为文件缓存</div><div class="line">@property (strong, readonly) YYMemoryCache *memoryCache;</div><div class="line">@property (strong, readonly) YYDiskCache *diskCache;</div><div class="line"></div><div class="line">// 通过下面三种方法来实例化YYCache对象</div><div class="line">- (nullable instancetype)initWithName:(NSString *)name;</div><div class="line">- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;</div><div class="line">+ (nullable instancetype)cacheWithName:(NSString *)name;</div><div class="line"></div><div class="line">+ (nullable instancetype)cacheWithPath:(NSString *)path;</div><div class="line"></div><div class="line">// 禁止通过下面两个方式实例化对象</div><div class="line">- (instancetype)init UNAVAILABLE_ATTRIBUTE;</div><div class="line">+ (instancetype)new UNAVAILABLE_ATTRIBUTE;</div><div class="line"></div><div class="line">// 通过key判断是否缓存 第二个法是异步执行,异步回调</div><div class="line">- (BOOL)containsObjectForKey:(NSString *)key;</div><div class="line">- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block;</div><div class="line"></div><div class="line">// 通过key读取缓存，第二个法是异步执行,异步回调</div><div class="line">- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;</div><div class="line">- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block;</div><div class="line"></div><div class="line">// 增、改--缓存对象(可缓存遵从NSCoding协议的对象)，第二个法是异步执行,异步回调</div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;</div><div class="line">- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block;</div><div class="line"></div><div class="line">// 删除缓存</div><div class="line">- (void)removeObjectForKey:(NSString *)key;</div><div class="line">- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;</div><div class="line">- (void)removeAllObjects;</div><div class="line">- (void)removeAllObjectsWithBlock:(void(^)(void))block;</div><div class="line">- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress</div><div class="line">                                 endBlock:(nullable void(^)(BOOL error))end;</div></pre></td></tr></table></figure>
<p>API设计的很简洁，使用起来十分方便。</p>
<h4 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h4><p>YYMemoryCache是内存缓存，所以存取速度非常快。但不同于一般的第三方NSCache的key-value存储方式，而是采用的<strong>CFDictionary</strong>和<strong>双向链表</strong>相结合的方式进行内存缓存。这种做的好处就是能够满足<strong>LRU</strong>（Least Recently Used）<strong>淘汰算法</strong>。它的层级结构是YYMemoryCache -&gt;_YYLinkedMap -&gt;_YYLinkedMapNode.</p>
<h5 id="YYLinkedMapNode"><a href="#YYLinkedMapNode" class="headerlink" title="_YYLinkedMapNode"></a>_YYLinkedMapNode</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface _YYLinkedMapNode : NSObject &#123;</div><div class="line">    @package</div><div class="line">    __unsafe_unretained _YYLinkedMapNode *_prev;</div><div class="line">    __unsafe_unretained _YYLinkedMapNode *_next;</div><div class="line">    id _key;</div><div class="line">    id _value;</div><div class="line">    NSUInteger _cost;</div><div class="line">    NSTimeInterval _time;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>@package 是为了不让framework外部对其进行操作（对于framework内部相当于protected 对于framework外部相当于private）</li>
<li>_YYLinkedMapNode *_prev 定义了一个指针指向前一个节点, _YYLinkedMapNode _next指向后一个节点。还有一点是都使用__unsafe_unretained修饰的。这是为了防止循环引用，因为采用的数据结构是双向链表，很可能出现循环强引用，最后就都不会给释放。</li>
<li>_key:缓存的键</li>
<li>_value:缓存的值</li>
<li>_cost存储这个value需要的内存开销</li>
<li>_time 最后访问时间</li>
</ol>
</blockquote>
<p> 通过以上6个成员变量，就能完成时间，空间，数量的淘汰算法了。    </p>
<h5 id="YYLinkedMap"><a href="#YYLinkedMap" class="headerlink" title="_YYLinkedMap"></a>_YYLinkedMap</h5><p>_YYLinkedMapNode是一个节点，那么_YYLinkedMap就是链表。链表的作用是将所有节点串联起来形成双向链表数据结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@interface _YYLinkedMap : NSObject &#123;</div><div class="line">    @package</div><div class="line">    CFMutableDictionaryRef _dic;// 用字典保存所有节点</div><div class="line">    NSUInteger _totalCost; // 总内存开销</div><div class="line">    NSUInteger _totalCount;// 总内存长度</div><div class="line">    _YYLinkedMapNode *_head; // MRU, 链表的头结点</div><div class="line">    _YYLinkedMapNode *_tail; // LRU, 链表的尾节点</div><div class="line">    BOOL _releaseOnMainThread; // 是否在主线程上，异步释放 _YYLinkedMapNode对象</div><div class="line">    BOOL _releaseAsynchronously;//是否异步释放 _YYLinkedMapNode对象</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h5><p><strong>insertNodeAtHead</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)insertNodeAtHead:(_YYLinkedMapNode *)node &#123;</div><div class="line">- </div><div class="line">    CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node));// 字典保存链表的节点node</div><div class="line">    _totalCost += node-&gt;_cost;// 叠加该缓存开销到总内存开销</div><div class="line">    _totalCount++; // 总缓存数+1</div><div class="line">    if (_head) &#123;</div><div class="line">        node-&gt;_next = _head; // 存在链表表头，取代当前表头</div><div class="line">        _head-&gt;_prev = node;</div><div class="line">        _head = node;  // 重新赋值链表表头临时变量_head</div><div class="line">    &#125; else &#123;</div><div class="line">        _head = _tail = node;  // 不存在链表表头</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>bringNodeToHead</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)bringNodeToHead:(_YYLinkedMapNode *)node &#123;</div><div class="line">    if (_head == node) return; // 当前节点已是链表头节点</div><div class="line">    </div><div class="line">    // 如果node是链表尾节点</div><div class="line">    if (_tail == node) &#123;</div><div class="line">        _tail = node-&gt;_prev; // 把node指向的上一个节点赋值给链表尾节点</div><div class="line">        _tail-&gt;_next = nil;// 把链表尾节点指向的下一个节点赋值nil</div><div class="line">    &#125; else &#123;</div><div class="line">        // 如果node是非链表尾节点和链表头节点</div><div class="line">        </div><div class="line">        //  把node指向的上一个节点赋值給node指向的下一个节点node指向的上一个节点</div><div class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</div><div class="line">        </div><div class="line">        //  把node指向的下一个节点赋值给node指向的上一个节点node指向的下一个节点</div><div class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</div><div class="line">    &#125;</div><div class="line">    node-&gt;_next = _head; // 把链表头节点赋值给node指向的下一个节点</div><div class="line">    node-&gt;_prev = nil;   // 把node指向的上一个节点赋值nil</div><div class="line">    _head-&gt;_prev = node;// 把节点赋值给链表头节点的指向的上一个节点</div><div class="line">    _head = node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>removeNode</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)removeNode:(_YYLinkedMapNode *)node &#123;</div><div class="line">    // 从字典中移除node</div><div class="line">    CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key));</div><div class="line">    _totalCost -= node-&gt;_cost;// 减掉总内存消耗</div><div class="line">    _totalCount--;// 总缓存数-1</div><div class="line">    </div><div class="line">    if (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev;</div><div class="line">    if (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next;</div><div class="line">    // 把node指向的下一个节点赋值给链表的头节点</div><div class="line">    if (_head == node) _head = node-&gt;_next;</div><div class="line">    // 把node指向上的节点赋值给链表尾节点</div><div class="line">    if (_tail == node) _tail = node-&gt;_prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>removeAll</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)removeAll &#123;</div><div class="line">   </div><div class="line">    _totalCost = 0;  // 清空内存开销与缓存数量</div><div class="line">    _totalCount = 0;</div><div class="line">    _head = nil;    // 清空头尾节点</div><div class="line">    _tail = nil;</div><div class="line"></div><div class="line">    if (CFDictionaryGetCount(_dic) &gt; 0) &#123;</div><div class="line">        // 拷贝一份字典</div><div class="line">        CFMutableDictionaryRef holder = _dic;</div><div class="line">        // 重新分配新的空间</div><div class="line">        _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line"></div><div class="line">        if (_releaseAsynchronously) &#123;</div><div class="line">            // 异步释放缓存</div><div class="line">            dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            dispatch_async(queue, ^&#123;</div><div class="line">                CFRelease(holder); </div><div class="line">            &#125;);</div><div class="line">        &#125; else if (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                CFRelease(holder);  // 主线程上释放缓存</div><div class="line">            &#125;);</div><div class="line">        &#125; else &#123;</div><div class="line">            CFRelease(holder);  // 同步释放缓存</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对一个Cache的操作分为三种：插入、替换、查找</p>
<blockquote>
<p>查找：每次数据项被查询到时，都将此数据项移动到链表头部<br>插入：当Cache未满时，新的数据项只需插到双链表头部即可<br>替换：当Cache已满时，将新的数据项插到双链表头部，并删除双链表的尾结点即可</p>
</blockquote>
<p>YYMemoryCache的实现都是通过调用上面的方法来实现的。</p>
<h4 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h4><p>YYDiskCache（表层类）是对YYKVStorage（实现类）的封装,缓存方式为：数据库+文件。</p>
<p>在说YYKVStorage之前先说一下<code>YYKVStorageItem</code><br><strong>YYKVStorageItem</strong>头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@interface YYKVStorageItem : NSObject</div><div class="line">@property (nonatomic, strong) NSString *key;                // 缓存键值</div><div class="line">@property (nonatomic, strong) NSData *value;                // 缓存对象</div><div class="line">@property (nullable, nonatomic, strong) NSString *filename; //  缓存文件名 </div><div class="line">@property (nonatomic) int size;                             // 缓存大小</div><div class="line">@property (nonatomic) int modTime;                          // 最后修改的时间戳</div><div class="line">@property (nonatomic) int accessTime;                       // 最后访问的时间戳</div><div class="line">@property (nullable, nonatomic, strong) NSData *extendedData; // 拓展数据</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>YYKVStorageItem指的是每一个存储的单元，这个存储单元的属性比较完善。YYKVStorage像一个manager用来管理每一个YYKVStorageItem,我们可以通过YYKVStorage来操作单个的YYKVStorageItem。比如获取，保存，移除等等</p>
<h5 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h5><p><strong>缓存类型</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123;</div><div class="line">    // 文件缓存(filename != null)</div><div class="line">    YYKVStorageTypeFile = 0,</div><div class="line">    // 数据库缓存</div><div class="line">    YYKVStorageTypeSQLite = 1,</div><div class="line">    // 如果filename == null,则用数据库缓存，否则用文件缓存</div><div class="line">    YYKVStorageTypeMixed = 2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>查询某个项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (YYKVStorageItem *)getItemForKey:(NSString *)key &#123;</div><div class="line">    if (key.length == 0) return nil;</div><div class="line">    // 数据库查询</div><div class="line">    YYKVStorageItem *item = [self _dbGetItemWithKey:key excludeInlineData:NO];</div><div class="line">    if (item) &#123;</div><div class="line">        //  更新操作时间</div><div class="line">        [self _dbUpdateAccessTimeWithKey:key];</div><div class="line">        if (item.filename) &#123;</div><div class="line">            // 读取文件</div><div class="line">            item.value = [self _fileReadWithName:item.filename];</div><div class="line">            if (!item.value) &#123;</div><div class="line">                // 删除数据库记录</div><div class="line">                [self _dbDeleteItemWithKey:key];</div><div class="line">                item = nil;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询缓存的操作步骤：</p>
<blockquote>
<p>1.先判断key是否为空<br>2.通过Key查找到对应的缓存项<br>3.如果查找成功，更新访问时间，然后通过文件名，读取数据，如果数据为空，则通过key删除对应的文件</p>
</blockquote>
<p><strong>查询多个项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (NSArray *)getItemForKeys:(NSArray *)keys &#123;</div><div class="line">    if (keys.count == 0) return nil;</div><div class="line">    NSMutableArray *items = [self _dbGetItemWithKeys:keys excludeInlineData:NO];</div><div class="line">    if (_type != YYKVStorageTypeSQLite) &#123;</div><div class="line">        for (NSInteger i = 0, max = items.count; i &lt; max; i++) &#123;</div><div class="line">            YYKVStorageItem *item = items[i];</div><div class="line">            if (item.filename) &#123;</div><div class="line">                item.value = [self _fileReadWithName:item.filename];</div><div class="line">                if (!item.value) &#123;</div><div class="line">                    if (item.key) [self _dbDeleteItemWithKey:item.key];</div><div class="line">                    [items removeObjectAtIndex:i];</div><div class="line">                    i--;</div><div class="line">                    max--;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (items.count &gt; 0) &#123;</div><div class="line">        [self _dbUpdateAccessTimeWithKeys:keys];</div><div class="line">    &#125;</div><div class="line">    return items.count ? items : nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查询多个缓存项步骤：</p>
<blockquote>
<ol>
<li>先判断需要查找的缓存数组是否为空</li>
<li>然后在数据库里拿到所有缓存项</li>
<li>遍历出每个缓存项，并确保值存在，不存在的删除掉</li>
<li>最后更新所有缓存项的访问时间</li>
</ol>
</blockquote>
<p><strong>添加缓存</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData &#123;</div><div class="line">    </div><div class="line">    //先判断key，value是否为空</div><div class="line">    if (key.length == 0 || value.length == 0) return NO;</div><div class="line">    // 缓存方式为YYKVStorageTypeFile并且文件名为空时 不缓存</div><div class="line">    if (_type == YYKVStorageTypeFile &amp;&amp; filename.length == 0) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (filename.length) &#123;</div><div class="line">        </div><div class="line">         // 缓存数据写入文件</div><div class="line">        if (![self _fileWriteWithName:filename data:value]) &#123;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        // 把key,filename,extendedData写入数据库,存在filenam,则不把value缓存进数据库</div><div class="line">        if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</div><div class="line">            //  如果数据库操作失败，删除之前的文件缓存</div><div class="line">            [self _fileDeleteWithName:filename];</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        return YES;</div><div class="line">    &#125; else &#123;</div><div class="line">        if (_type != YYKVStorageTypeSQLite) &#123;</div><div class="line">            // 根据key查找缓存文件名</div><div class="line">            NSString *filename = [self _dbGetFilenameWithKey:key];</div><div class="line">            if (filename) &#123;</div><div class="line">                // 删除文件缓存</div><div class="line">                [self _fileDeleteWithName:filename];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 把缓存写入数据库</div><div class="line">        return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加缓存的操作步骤：</p>
<blockquote>
<ol>
<li>先判断key，value是否为空</li>
<li>filename不为空的情况下，先将NSData写入磁盘文件，然后向数据库插入一条磁盘缓存文件的表记录。filename为空的情况下，根据key查询表中记录缓存项的filename字段,删除查询到的filename对应的缓存文件,更新key对应的缓存表记录的filename字段，清空为nil</li>
</ol>
</blockquote>
<p><strong>删除缓存</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (BOOL)removeItemForKey:(NSString *)key &#123;</div><div class="line">    if (key.length == 0) return NO;</div><div class="line">    //  判断缓存方式</div><div class="line">    switch (_type) &#123;</div><div class="line">        case YYKVStorageTypeSQLite: &#123;</div><div class="line">            //  删除数据库记录</div><div class="line">            return [self _dbDeleteItemWithKey:key];</div><div class="line">        &#125; break;</div><div class="line">        case YYKVStorageTypeFile:</div><div class="line">        case YYKVStorageTypeMixed: &#123;</div><div class="line">            //  数据库缓存或文件缓存</div><div class="line">            // 查找缓存文件名</div><div class="line">            NSString *filename = [self _dbGetFilenameWithKey:key];</div><div class="line">            if (filename) &#123;</div><div class="line">                // 删除文件缓存</div><div class="line">                [self _fileDeleteWithName:filename];</div><div class="line">            &#125;</div><div class="line">               // 删除数据库记录</div><div class="line">            return [self _dbDeleteItemWithKey:key];</div><div class="line">        &#125; break;</div><div class="line">        default: return NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除缓存项的操作步骤：</p>
<blockquote>
<ol>
<li>先判断key是否为空</li>
<li>判断缓存方式是哪一种.如果是sqlite存储，删除sqlite里对应的缓存项。如果是文件存储，先获取文件名，然后删除。</li>
</ol>
</blockquote>
<p><strong>删除所有项</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (BOOL)removeAllItems &#123;</div><div class="line">    if (![self _dbClose]) return NO;</div><div class="line">    [self _reset];</div><div class="line">    if (![self _dbOpen]) return NO;</div><div class="line">    if (![self _dbInitialize]) return NO;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除所有目录的操作步骤：</p>
<blockquote>
<ol>
<li>首先关闭数据库，并确认已经关闭</li>
<li>格式化数据库，移除db.sqlite,db.sqlite-shm,db.sqlite-wal文件,将所有磁盘文件移动到Trash目录下,然后将删除Trash目录下文件的操作，放到子线程队列上异步执行</li>
<li>初始化数据库</li>
</ol>
</blockquote>
<h5 id="删除缓存策略"><a href="#删除缓存策略" class="headerlink" title="删除缓存策略"></a>删除缓存策略</h5><p>设计缓存时，一定会考虑删除策略，比如SDWebImage中就设计了比较好的删除策略。YYKVStorage的删除缓存策略如下：</p>
<blockquote>
<ul>
<li>删除所有内存开销大于size的缓存</li>
<li>删除所有时间比time小的缓存</li>
<li>减小缓存占的容量开销，使总缓存的容量开销值不大于maxSize(删除原则：LRU 最久未使用的缓存将先删除)</li>
<li>减小总缓存数量，使总缓存数量不大于maxCount(删除原则：LRU 最久未使用的缓存将先删除)</li>
</ul>
</blockquote>
<p>补充：在沙盒下的SQLite数据库包含三个文件：db.sqlite，db.sqlite-wal ，db.sqlite-shm。在介绍这三个文件之前，说一下WAL机制。在引入WAL机制之前，SQLite使用rollback机制实现原子事务</p>
<blockquote>
<ul>
<li>rollback 机制原理：在修改数据库文件中的数据之前，先将修改所在分页中的数据备份在另外一个地方，然后才将修改写入到数据库文件中；如果事务失败，则将备份数据拷贝回来，撤销修改；如果事务成功，则删除备份数据，提交修改。</li>
<li>WAL机制原理：修改并不直接写入到数据库文件中，而是写入到另外一个称为WAL的文件中；如果事务失败，WAL中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改 </li>
</ul>
</blockquote>
<p><strong>db.sqlite</strong>：存放数据库本身的数据: 表、表记录、index、sequence …<br><strong>db.sqlite-wal</strong>：wal全称是Write Ahead Logging。很多数据库中用于实现原子事务的一种机制。同样数据库必须开启WAL模式，用于数据库实现实现原子事务，当创建第一个数据库连接时创建 db-wal文件，当最后一个数据库连接关闭时删除 db-wal文件<br><strong>db.sqlite-shm</strong>：存放的是Shared-Memory Files，数据库必须开启WAL模式，当多个线程/进程访问同一个数据库时，让每一个数据库连接可以进行内存数据共享，随着 db-wal文件创建而创建，删除而删除</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在iOS 开发中总会用到各种缓存。通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。&lt;a href=&quot;https://github.com/ibireme/YYCache&quot;&gt;YYCache&lt;/a&gt;或许是最好的选择之一。性能上有优势，用法也很简单。在阅读完源码之后，记录一下源码解析笔记。&lt;/p&gt;
&lt;h4 id=&quot;层级结构&quot;&gt;&lt;a href=&quot;#层级结构&quot; class=&quot;headerlink&quot; title=&quot;层级结构&quot;&gt;&lt;/a&gt;层级结构&lt;/h4&gt;&lt;p&gt;YYCache是对内存缓存和磁盘缓存的封装。YYMemoryCache为内存缓存，YYDiskCache为磁盘缓存，YYKVStorage为磁盘缓存的底层实现。下面看一下具体的实现细节。&lt;/p&gt;
&lt;h4 id=&quot;YYCache&quot;&gt;&lt;a href=&quot;#YYCache&quot; class=&quot;headerlink&quot; title=&quot;YYCache&quot;&gt;&lt;/a&gt;YYCache&lt;/h4&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>异步绘制-YYAsyncLayer</title>
    <link href="http://chaosyuan.github.io/2016/05/05/2016-05-05-yi-bu-hui-zhi-yyasynclayer/"/>
    <id>http://chaosyuan.github.io/2016/05/05/2016-05-05-yi-bu-hui-zhi-yyasynclayer/</id>
    <published>2016-05-05T12:08:50.000Z</published>
    <updated>2016-08-19T01:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>　<a href="https://github.com/ibireme/YYAsyncLayer" target="_blank" rel="external">YYAsyncLayer</a>是异步绘制与显示的工具。在YYKitDemo中为了保证列表滚动流畅，将视图绘制、以及图片解码等任务放在后台线程。极大的优化了列表的性能。在阅读源码之后，整理一下异步绘制整体的实现思路。</p>
<h4 id="YYAsyncLayer"><a href="#YYAsyncLayer" class="headerlink" title="YYAsyncLayer"></a>YYAsyncLayer</h4><p>首先介绍一下<strong>YYAsyncLayer</strong>几个类：</p>
<blockquote>
<ul>
<li>YYAsyncLayer：继承自CALayer，是用来异步渲染layer内容，创建绘制的部分都在这个类</li>
<li>YYSentinel：提供获取当前值的value（readonly）属性，以及- (int32_t)increase自增加的方法返回一个新的value值，用于判断异步绘制任务是否被取消</li>
<li>YYTransaction：用于创建RunLoopObserver监听Runloop的空闲时间，并将YYTranaction对象提交到集合中</li>
</ul>
</blockquote>
<a id="more"></a>
<p>YYAsyncLayer类中只有一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property BOOL displaysAsynchronously; //设置渲染是否是异步执行 默认YES</div></pre></td></tr></table></figure>
<p>代理方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (YYAsyncLayerDisplayTask *)newAsyncDisplayTask</div></pre></td></tr></table></figure>
<p>这个代理方法的触发时机是,当layer的内容需要更新的时候，生成新的绘制任务，返回一个<strong>YYAsyncLayerDisplayTask</strong>对象.</p>
<p>比如需要绘制Label绘制一个lable时，其实是继承自UIView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (Class)layerClass &#123;</div><div class="line">    return YYAsyncLayer.class;</div><div class="line">&#125;</div><div class="line">- (void)setFont:(UIFont *)font &#123;</div><div class="line">    _font = font;</div><div class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)layoutSubviews &#123;</div><div class="line">    [super layoutSubviews];</div><div class="line">    [[YYTransaction transactionWithTarget:self selector:@selector(contentsNeedUpdated)] commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>YYTransaction有selector、target的属性，selector就是contentsNeedUpdated方法，此时并不会立即在后台线程去更新显示，而是将YYTransaction对象本身提交保存在transactionSet的容器集合中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (YYTransaction *)transactionWithTarget:(id)target selector:(SEL)selector&#123;</div><div class="line">    if (!target || !selector) return nil;</div><div class="line">    YYTransaction *t = [YYTransaction new];</div><div class="line">    t.target = target;</div><div class="line">    t.selector = selector;</div><div class="line">    return t;</div><div class="line">&#125;</div><div class="line">- (void)commit &#123;</div><div class="line">    if (!_target || !_selector) return;</div><div class="line">    YYTransactionSetup();</div><div class="line">    [transactionSet addObject:self];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　同时在YYTransaction.m中注册一个RunloopObserver，监听MainRunloop在kCFRunLoopCommonModes下的kCFRunLoopBeforeWaiting（Runloop将要进入休眠）和kCFRunLoopExit（即将退出本次Runloop）的状态，在一次Runloop空闲时去执行更新显示的操作。利用Runloop做任务分发。从代码注释中看出Observer的优先级低于CATransaction的优先级。当 RunLoop 进入休眠前、CA 处理完事件后，就会执行该 Runloop 内提交的所有任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">static void YYTransactionSetup() &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        transactionSet = [NSMutableSet new];</div><div class="line">        CFRunLoopRef runloop = CFRunLoopGetMain();</div><div class="line">        CFRunLoopObserverRef observer;</div><div class="line">        </div><div class="line">        observer = CFRunLoopObserverCreate(CFAllocatorGetDefault(),</div><div class="line">                                           kCFRunLoopBeforeWaiting | kCFRunLoopExit,</div><div class="line">                                           true,      // repeat</div><div class="line">                                           0xFFFFFF,  // after CATransaction(2000000)</div><div class="line">                                           YYRunLoopObserverCallBack, NULL);</div><div class="line">        CFRunLoopAddObserver(runloop, observer, kCFRunLoopCommonModes);</div><div class="line">        CFRelease(observer);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在RunloopObserver的回调方法，从transactionSet取出transaction对象执行SEL的方法，分发到每一次Runloop执行，避免一次Runloop执行时间太长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static void YYRunLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</div><div class="line">    if (transactionSet.count == 0) return;</div><div class="line">    NSSet *currentSet = transactionSet;</div><div class="line">    transactionSet = [NSMutableSet new];</div><div class="line">    [currentSet enumerateObjectsUsingBlock:^(YYTransaction *transaction, BOOL *stop) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;</div><div class="line">        [transaction.target performSelector:transaction.selector];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于这一点是参考<a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a>实现的。两者者实现的思路是一样。</p>
<p>YYAsyncLayerDisplayTask 中定义3个block，用于绘制的回调操作，即将绘制、绘制中、绘制完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nullable, nonatomic, copy) void (^willDisplay)(CALayer *layer);</div><div class="line">@property (nullable, nonatomic, copy) void (^display)(CGContextRef context, CGSize size, BOOL(^isCancelled)(void));</div><div class="line">@property (nullable, nonatomic, copy) void (^didDisplay)(CALayer *layer, BOOL finished);</div></pre></td></tr></table></figure>
<p>触发这个代理的方法是- setNeedsDisplay方法，当layer需要更新内容的时候，它会向代理发起一个异步绘制的请求，将内容的渲染放到后台队列去做，所以在使用YYAsyncLayer类时，需要重写<code>+ (Class)layerClass</code>方法，返回YYAsyncLayer类，否则会直接调用CALayer的方法，不会触发代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)setNeedsDisplay &#123;</div><div class="line">    [self _cancelAsyncDisplay];</div><div class="line">    [super setNeedsDisplay];</div><div class="line">&#125;</div><div class="line">- (void)display &#123;</div><div class="line">    super.contents = super.contents;</div><div class="line">    [self _displayAsync:_displaysAsynchronously];</div><div class="line">&#125;</div><div class="line">- (void)_displayAsync:(BOOL)async &#123;</div><div class="line">    __strong id&lt;YYAsyncLayerDelegate&gt; delegate = self.delegate;</div><div class="line">    YYAsyncLayerDisplayTask *task = [delegate newAsyncDisplayTask];</div><div class="line">    //......</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在- _displayAsync方法里面主要分成3部分：</p>
<blockquote>
<ol>
<li>如果没有设置display回调，layer的内容会被清空</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (!task.display) &#123;</div><div class="line"></div><div class="line">   if (task.willDisplay) task.willDisplay(self);</div><div class="line">   self.contents = nil;</div><div class="line">   if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">   return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>异步绘制,根据displaysAsynchronously判断</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">if (async) &#123;</div><div class="line">        if (task.willDisplay) task.willDisplay(self);</div><div class="line">        YYSentinel *sentinel = _sentinel;</div><div class="line">        // 判断当前计数是否等于之前计数</div><div class="line">        int32_t value = sentinel.value;</div><div class="line">        BOOL (^isCancelled)() = ^BOOL() &#123;</div><div class="line">            return value != sentinel.value;</div><div class="line">        &#125;;</div><div class="line">        CGSize size = self.bounds.size;</div><div class="line">        BOOL opaque = self.opaque;</div><div class="line">        CGFloat scale = self.contentsScale;</div><div class="line">        CGColorRef backgroundColor = (opaque &amp;&amp; self.backgroundColor) ? CGColorRetain(self.backgroundColor) : NULL;</div><div class="line">        if (size.width &lt; 1 || size.height &lt; 1) &#123; // 视图宽高小于1</div><div class="line">            CGImageRef image = (__bridge_retained CGImageRef)(self.contents);</div><div class="line">            self.contents = nil;</div><div class="line">            if (image) &#123;</div><div class="line">                dispatch_async(YYAsyncLayerGetReleaseQueue(), ^&#123;</div><div class="line">                    CFRelease(image);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">            CGColorRelease(backgroundColor);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">         // 异步绘制</div><div class="line">        dispatch_async(YYAsyncLayerGetDisplayQueue(), ^&#123;</div><div class="line">            if (isCancelled()) &#123;</div><div class="line">                CGColorRelease(backgroundColor);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            // 开启图片上下文</div><div class="line">            UIGraphicsBeginImageContextWithOptions(size, opaque, scale);</div><div class="line">            CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">            if (opaque) &#123; // 不透明</div><div class="line">                CGContextSaveGState(context); &#123;</div><div class="line">                    if (!backgroundColor || CGColorGetAlpha(backgroundColor) &lt; 1) &#123;</div><div class="line">                        CGContextSetFillColorWithColor(context, [UIColor whiteColor].CGColor);</div><div class="line">                        CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale));</div><div class="line">                        CGContextFillPath(context);</div><div class="line">                    &#125;</div><div class="line">                    if (backgroundColor) &#123;</div><div class="line">                        CGContextSetFillColorWithColor(context, backgroundColor);</div><div class="line">                        CGContextAddRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale));</div><div class="line">                        CGContextFillPath(context);</div><div class="line">                    &#125;</div><div class="line">                &#125; CGContextRestoreGState(context);</div><div class="line">                CGColorRelease(backgroundColor);</div><div class="line">            &#125;</div><div class="line">            task.display(context, size, isCancelled);</div><div class="line">            if (isCancelled()) &#123;</div><div class="line">                UIGraphicsEndImageContext();</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">                &#125;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            // 从图片上下文获取图片</div><div class="line">            UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">            UIGraphicsEndImageContext();</div><div class="line">            if (isCancelled()) &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">                &#125;);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (isCancelled()) &#123;</div><div class="line">                    if (task.didDisplay) task.didDisplay(self, NO);</div><div class="line">                &#125; else &#123;</div><div class="line">                    self.contents = (__bridge id)(image.CGImage);</div><div class="line">                    if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>同步绘制</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">   [_sentinel increase];</div><div class="line">    if (task.willDisplay) task.willDisplay(self);</div><div class="line">    UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.opaque, self.contentsScale);</div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    if (self.opaque) &#123;</div><div class="line">       //......</div><div class="line">    &#125;</div><div class="line">    task.display(context, self.bounds.size, ^&#123;return NO;&#125;);</div><div class="line">    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    self.contents = (__bridge id)(image.CGImage);</div><div class="line">    if (task.didDisplay) task.didDisplay(self, YES);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>异步渲染的处理和同步渲染差不多，多了一个BOOL (^isCancelled)()block，这个block的好处是，在displayblock调用绘制前，可以通过判断isCancelled布尔值的值来停止绘制，减少性能上的消耗，以及避免出现线程阻塞的情况，比如TableView快速滑动的时候，就可以通过这样的判断，来避免不必要的绘制，提升滑动的流畅性.</p>
<p>下图为异步绘制实现的整体思路：<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/YYAsyncLayer.png" alt="enter image description here"></p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>从YYAsyncLayer中学到的一些技巧，项目中遇到的性能问题可也以依据这些思路去找到最合适的解决方案</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;　&lt;a href=&quot;https://github.com/ibireme/YYAsyncLayer&quot;&gt;YYAsyncLayer&lt;/a&gt;是异步绘制与显示的工具。在YYKitDemo中为了保证列表滚动流畅，将视图绘制、以及图片解码等任务放在后台线程。极大的优化了列表的性能。在阅读源码之后，整理一下异步绘制整体的实现思路。&lt;/p&gt;
&lt;h4 id=&quot;YYAsyncLayer&quot;&gt;&lt;a href=&quot;#YYAsyncLayer&quot; class=&quot;headerlink&quot; title=&quot;YYAsyncLayer&quot;&gt;&lt;/a&gt;YYAsyncLayer&lt;/h4&gt;&lt;p&gt;首先介绍一下&lt;strong&gt;YYAsyncLayer&lt;/strong&gt;几个类：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;YYAsyncLayer：继承自CALayer，是用来异步渲染layer内容，创建绘制的部分都在这个类&lt;/li&gt;
&lt;li&gt;YYSentinel：提供获取当前值的value（readonly）属性，以及- (int32_t)increase自增加的方法返回一个新的value值，用于判断异步绘制任务是否被取消&lt;/li&gt;
&lt;li&gt;YYTransaction：用于创建RunLoopObserver监听Runloop的空闲时间，并将YYTranaction对象提交到集合中&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS－UITableView性能优化</title>
    <link href="http://chaosyuan.github.io/2016/04/29/2016-04-29-ios%5Bnil%5Duitableviewxing-neng-you-hua/"/>
    <id>http://chaosyuan.github.io/2016/04/29/2016-04-29-ios[nil]uitableviewxing-neng-you-hua/</id>
    <published>2016-04-29T11:37:40.000Z</published>
    <updated>2016-08-19T01:59:57.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>UITableView</strong>是iOS再熟悉不过的视图了,在实际开发用的也比较频繁，在开发过程中碰到一些问题–比如屏幕掉帧、卡顿等现象。这些现象大幅度的降低了用户的性能体验，并提高了crash的频率。在公司之前的项目开发中。对其中的性能优化也只停留表面的层级上。并没有真正理解产生问题的原因。所以抽出时间。对UITableView的性能优化做一个总结。</p>
<a id="more"></a>
<h4 id="UITableView-执行顺序"><a href="#UITableView-执行顺序" class="headerlink" title="UITableView 执行顺序"></a>UITableView 执行顺序</h4><p>首先说一下tableView的delegate以及dataSource方法的执行顺序。当tableview需要显示内容的时候，首先发送网络请求，向服务器请求数据，然后将数据转为可以使用的model后进行reload操作。这时候会先调用（默认section为1）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</div></pre></td></tr></table></figure>
<p>根据model的个数来获取cell的行数。然后询问 delegate 这些 cell 应该显示的高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</div></pre></td></tr></table></figure>
<p>由于UITableView 是个UIScrollView。滑动范围由属性contentSize来确定。所以tableView加载时需要指定 contentSize。它的contentSize取决于所有cell的高度和。然后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div></pre></td></tr></table></figure>
<p>创建并显示cell</p>
<h4 id="性能产生的原因"><a href="#性能产生的原因" class="headerlink" title="性能产生的原因"></a>性能产生的原因</h4><p>产生性能主要有两方面：</p>
<blockquote>
<ol>
<li>计算布局</li>
<li>绘制显示</li>
</ol>
</blockquote>
<p>大多数情况下是将model直接传给cell然后在cell里进行计算各控件的相对位置.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-(void)setModel:(Model *)model&#123;</div><div class="line">    _model = model;</div><div class="line">    self.contentLabel.text = model.content;</div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是这样做的话假如滑动比较快，且内部控件比较复杂会导致CPU的计算量过大，从而由于掉帧而造成卡顿。这个之前我也很疑惑为什么会掉帧?后来查看部分资料及<a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">yy大神</a>博客后，才明白这一部分理论。</p>
<p>这里我简单的说一下，因为GPU一个机制叫做垂直同步(Vertical Hold。简写V-Sync)，当开启垂直同步时。显示器刷新一帧后就会产生一个垂直同步信号。GPU在渲染每一帧之前会等待垂直同步信号，只有显示器完成了一次刷新时，发出V-Sync信号后，GPU才进行新的一帧渲染和缓冲区更新（也就是说GPU的渲染能力会受到显示器刷新率的制约。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p>
<p>当 V-Sync 信号到来后，CPU开始进行内部控件的创建、布局、图片解码、文本绘制等。然后CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区，等待下一次 V-Sync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交(也就是超过了1个VSync周期)，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是会造成掉帧的原因。</p>
<h4 id="如何性能优化"><a href="#如何性能优化" class="headerlink" title="如何性能优化"></a>如何性能优化</h4><p>性能优化的最终目的：平衡CPU和GPU的压力。正确地利用了CPU和GPU资源，使它们均匀地负载，这样使得FPS会保持在60帧。避免出现CPU满载GPU低负载或者GPU满载CPU低负载的情况。</p>
<h4 id="计算布局性能优化"><a href="#计算布局性能优化" class="headerlink" title="计算布局性能优化"></a>计算布局性能优化</h4><p>计算布局优化也就是避免出现CPU满载GPU低负载的情况。<br>尽量不要使用Autolayout，可能使用进行手动布局可能会麻烦点，但是通过简单的加减乘除就可以获取控件相对位置和cell的高度。AutoLayout是苹果提倡使用。但是对于复杂视图来说常常会产生性能问题。子视图越多。CPU通过AutoLayout计算布局会约吃力。这是因为AutoLayout需要根据底层“Cassowary”的约束求解系统进行约束计算，从而得到一个唯一解。如果内部的子视图越多，它需要进行的计算量就越大，需要求解的约束越多，CPU计算布局耗费大量时间从而导致超过了一个VSync周期。如果使用手动布局，只是简单的线性计算（top/left/bottom/right）。减少了CPU的负载.</p>
<p>将cell的高度以及子视图的布局封装为成一个对象，cell显示之前在异步线程计算好所有布局对象，并存入数组，每次调用tableView: heightForRowAtIndexPath :只需要从数组中取出，可避免重复的布局计算。<br>说到 cell高度计算及预缓存等功能，<a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">forkingdog</a>开源了一个很不错的库。</p>
<h4 id="绘制显示性能优化"><a href="#绘制显示性能优化" class="headerlink" title="绘制显示性能优化"></a>绘制显示性能优化</h4><p>绘制显示优化也就是避免出现GPU满载CPU低负载的情况。<br>在介绍GPU方面性能优化之前，我先说一下屏幕渲染。<br>OpenGL中,GPU<strong>屏幕渲染</strong>有两种方式：</p>
<blockquote>
<ol>
<li><strong>On-Screen Rendering</strong> (<strong>当前屏幕渲染</strong>) 指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行</li>
<li><strong>Off-Screen Rendering</strong> (<strong>离屏渲染</strong>) 指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作.</li>
</ol>
</blockquote>
<p>GPU方面性能优化体现在，在调用tableView: cellForRowAtIndexPath时，对cell内部视图绘制布局，以及图片的绘制解码等</p>
<blockquote>
<ol>
<li>当多个视图(或者CALayer)重叠时，GPU会对其进行合成渲染，而渲染最慢的操作之一是混合，因此当视图结构太复杂就会消耗大量GPU资源。为此应当尽量减少视图数量和层次。当一个视图是不透明的，注意设定layer.opaque = YES（而不是网上普遍认为view.opaque = YES)。可以避免无用的Alpha通道合成，降低GPU负载</li>
<li>当设置mask(遮罩)，shadows(阴影)，opacity(不透明),antialiasing(抗锯齿)等属性时,触发离屏渲染（offscreen rendering），而这个是在GPU中进行的，所以快速滑动tableView时，假如圆角对象较多，会导致GPU负载大增。这时候可以设置layer.shouldRasterize属性为YES。更为彻底的做法是直接在后台绘制圆角图片然后输出到主线程显示，避免使用圆角、阴影、遮罩等属性</li>
<li>使用drawRect:方法, 因为CoreGraphic 方法通常都是线程安全的，所以可以直接将文字和图片放到后台线程进异步绘制。然后输出到主线程上。将GPU的部分渲染转接给CPU</li>
</ol>
</blockquote>
<p>shouldRasterize（光栅化）: 将图转化为一个个栅格组成的图象。 光栅化特点：每个元素对应帧缓冲区中的一像素。</p>
<p>shouldRasterize = YES在其它属性触发离屏渲染的同时,会将光栅化后的内容缓存起来,如果对应的layer或者 sublayers没有发生改变,在下一帧的时候可以直接复用,从而减少渲染的频率。对于经常变动的内容,不要开启,否则会造成性能浪费.</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>性能优化要注意平衡CPU和GPU的负载。对于网上一些文章得出的结论，需要理性分析。只有通过自己的思考和实践才能得出较好的定论。</p>
<h4 id="详细参考"><a href="#详细参考" class="headerlink" title="详细参考"></a>详细参考</h4><ol>
<li>YYKIt作者 <a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a>（个人收获比较大）</li>
<li>seedante <a href="http://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="external">离屏渲染优化</a></li>
<li><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">优化UITableViewCell高度计算的那些事</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;UITableView&lt;/strong&gt;是iOS再熟悉不过的视图了,在实际开发用的也比较频繁，在开发过程中碰到一些问题–比如屏幕掉帧、卡顿等现象。这些现象大幅度的降低了用户的性能体验，并提高了crash的频率。在公司之前的项目开发中。对其中的性能优化也只停留表面的层级上。并没有真正理解产生问题的原因。所以抽出时间。对UITableView的性能优化做一个总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS多线程开发－线程安全</title>
    <link href="http://chaosyuan.github.io/2016/04/16/2016-04-16-iosduo-xian-cheng-kai-fa-%5Bnil%5Dxian-cheng-an-quan/"/>
    <id>http://chaosyuan.github.io/2016/04/16/2016-04-16-iosduo-xian-cheng-kai-fa-[nil]xian-cheng-an-quan/</id>
    <published>2016-04-16T13:07:52.000Z</published>
    <updated>2016-08-19T02:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>说到多线程就不得不说线程中的锁机制，多线程操作过程中往往多个线程是并发执行的。也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件和同一个方法等。因此当多个线程访问同一块资源时，很容易会发生数据错误及数据不安全等问题。因此要避免这些问题，需要使用“线程锁”来实现。</p>
<a id="more"></a>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥。obj就是互斥信号量。</p>
<pre><code>    NSObject *obj = [[NSObject alloc]init];
NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^{
    @synchronized(obj) {
        NSLog(@&quot;A&quot;);
        sleep(3);
        NSLog(@&quot;B&quot;);
    }
}];
[operation1 start];

NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^{
    sleep(2);
    @synchronized(obj) {
        NSLog(@&quot;C&quot;);
    }
}];
[operation2 start];
</code></pre><p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-04-16 15:54:12.622 iOS 锁机制[9537:144219] A</div><div class="line">2016-04-16 15:54:15.627 iOS 锁机制[9537:144219] B</div><div class="line">2016-04-16 15:54:17.629 iOS 锁机制[9537:144219] C</div></pre></td></tr></table></figure>
<p>使用@synchronized指令实现锁的优点就是不需要在代码中显式的创建锁对象，便可以实现锁的机制，作为一种预防措施，@synchronized块会隐式的添加一个异常处理来保护代码，其他试图执行该段代码的线程都会被阻塞，直到加锁线程退出执行该段被保护的代码段，也就是说@synchronized()代码块中的最后一条语句被执行完毕的时候。</p>
<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><p>NSLock最基本的锁对象,除lock和unlock方法外.NSLock类还提供tryLock方法，意思是尝试锁定，当锁定失败时，不会阻塞进程，而是会返回NO。也可以使用lockBeforeDate:方法，意思是在指定时间之前尝试锁定，如果在指定时间前都不能锁定，也是会返回NO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">    NSLock *lock = [[NSLock alloc] init];</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    //尝试锁定，当锁定失败时，不会阻塞进程，而是会返回NO</div><div class="line">    if ([lock tryLock]) &#123;</div><div class="line">        NSLog(@&quot;锁可用操作&quot;);</div><div class="line">        [lock unlock];</div><div class="line">    &#125;else&#123;</div><div class="line">        NSLog(@&quot;锁不可用操作&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">NSDate *date = [[NSDate alloc] initWithTimeIntervalSinceNow:3];</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    //指定时间之前尝试锁定，如果在指定时间前都不能锁定，也是会返回NO。</div><div class="line">    if ([lock lockBeforeDate:date]) &#123;</div><div class="line">        NSLog(@&quot;可以指定时间前可以锁定&quot;);</div><div class="line">        [lock unlock];</div><div class="line">    &#125;else &#123;</div><div class="line">        NSLog(@&quot;指定时间前都不能锁定&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：锁定(lock)和解锁(unLock)必须配对使用</p>
</blockquote>
<h4 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h4><p>NSRecursiveLock实际上定义的是一个递归锁，这个锁可以被同一线程多次请求，而不会引起死锁。主要是用在循环或递归操作中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">   NSLock *lock = [[NSLock alloc] init];</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"></div><div class="line">    static void (^recurSiveMothod)(int);</div><div class="line">    </div><div class="line">     recurSiveMothod   = ^(int value)&#123;</div><div class="line">         </div><div class="line">         [lock lock];</div><div class="line">         if (value &gt; 0) &#123;</div><div class="line">             NSLog(@&quot;value = %d&quot;,value);</div><div class="line">             sleep(2);</div><div class="line">             recurSiveMothod(value - 1);</div><div class="line">         &#125;</div><div class="line">         [lock unlock];</div><div class="line">    &#125;;</div><div class="line">    recurSiveMothod(6);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码是一个典型的死锁情况。在线程中RecursiveMethod是递归调用的。所以每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了.调试器中会输出如下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2016-04-16 16:38:49.312 iOS 锁机制[11856:202651] value = 6</div><div class="line">2016-04-16 16:38:51.318 iOS 锁机制[11856:202651] *** -[NSLock lock]: deadlock (&lt;NSLock: 0x7f9b2be0da70&gt; &apos;(null)&apos;)</div></pre></td></tr></table></figure>
<p>在这种情况下，就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。将NSLock替换成NSRecursiveLock就可以正确执行了。</p>
<h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><p>当在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSConditionLock *conLock = [[NSConditionLock alloc] init];</div><div class="line">//线程1</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    </div><div class="line">    for (int i = 0; i &lt;= 3; i++) &#123;</div><div class="line">        [conLock lock];</div><div class="line">        NSLog(@&quot;i = %d&quot;,i);</div><div class="line">        sleep(3);</div><div class="line">        [conLock unlockWithCondition:i];</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">//线程2</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    [conLock lockWhenCondition:3];</div><div class="line">     NSLog(@&quot;thread2&quot;);</div><div class="line">    [conLock unlock];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在线程1中的加锁使用了lock，是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock配对的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与需求相关的。</p>
<p>上面代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">2016-04-16 17:04:11.878 iOS 锁机制[12382:216548] i = 0</div><div class="line">2016-04-16 17:04:14.883 iOS 锁机制[12382:216548] i = 1</div><div class="line">2016-04-16 17:04:17.887 iOS 锁机制[12382:216548] i = 2</div><div class="line">2016-04-16 17:04:20.892 iOS 锁机制[12382:216548] i = 3</div><div class="line">2016-04-16 17:04:23.895 iOS 锁机制[12382:216547] thread2</div></pre></td></tr></table></figure>
<h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p>NSCondition一种最基本的条件锁。手动控制线程wait和signal。</p>
<blockquote>
<p>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问<br>[condition unlock];与lock 同时使用<br>[condition wait];让当前线程处于等待状态<br>[condition signal];CPU发信号告诉线程不用在等待，可以继续执行</p>
</blockquote>
<h4 id="NSDistributedLock"><a href="#NSDistributedLock" class="headerlink" title="NSDistributedLock"></a>NSDistributedLock</h4><blockquote>
<p>NSDistributedLock是MAC下的多进程开发中,一个非常方便的分布式锁。由于MAC接触很少。<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSDistributedLock_Class/index.html" target="_blank" rel="external">详细参考</a></p>
</blockquote>
<h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><p>pthread_mutex属于C语言下的加锁方式，使用时需要在头文件中导入：<strong>#import <pthread.h></pthread.h></strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">__block pthread_mutex_t mutex;</div><div class="line">pthread_mutex_init(&amp;mutex, NULL);</div><div class="line"></div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    NSLog(@&quot;线程同步的操作1开始&quot;);</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;线程同步的操作1结束&quot;);</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    </div><div class="line">    sleep(1);</div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    NSLog(@&quot;线程同步操作2&quot;);</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li><strong>pthread_mutex_init(pthread_mutex_t <em> __restrict,const pthread_mutexattr_t </em> __restrict)</strong>初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</li>
<li><strong>pthread_mutex_lock(pthread_mutex_t mutex)</strong>;加锁</li>
<li><strong>pthread_mutex_tylock(<em>pthread_mutex_t </em>mutex)</strong>;加锁，但是与2不一样的是.当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</li>
<li><strong>pthread_mutex_unlock(pthread_mutex_t *mutex)</strong>;释放锁</li>
<li><strong>pthread_mutex_destroy(pthread_mutex_t* mutex)</strong>;使用完后释放</li>
</ol>
<p>上面代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2016-04-16 17:38:33.631 iOS 锁机制[13086:235655] 线程同步的操作1开始</div><div class="line">2016-04-16 17:38:36.634 iOS 锁机制[13086:235655] 线程同步的操作1结束</div><div class="line">2016-04-16 17:38:36.635 iOS 锁机制[13086:235651] 线程同步操作2</div></pre></td></tr></table></figure>
<h4 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h4><p>GCD提供一种信号的机制，当信号总量设为 1 时使用它可以创建“锁”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_semaphore_t semaphore  =  dispatch_semaphore_create(1);</div><div class="line">NSMutableArray *array = [NSMutableArray array];</div><div class="line"> </div><div class="line"> for (int i = 0; i &lt; 1000; i++) &#123;</div><div class="line">     dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">         dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</div><div class="line">         [array addObject:[NSNumber numberWithInt:i]];</div><div class="line">         NSLog(@&quot;array = %@&quot;,array);</div><div class="line">         dispatch_semaphore_signal(semaphore);</div><div class="line">     &#125;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Dispatch Semaphore是持有计数的信号，该计数是多线程编程中的计数类型信号，类似于在停车场停车的概念，一开始有N个车位，当N等于0时等待，当N大于0时，停一辆车N减一而无需等待<br>dispatch_semaphore相关的共有三个函数：</p>
<blockquote>
<ol>
<li><strong>dispatch_semaphore_tdispatch_semaphore_create(long value)</strong> 这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL，一般初始值为1</li>
<li><strong>dispathc_semaphore_wait(semaphore,dispatch_time_t timeout)</strong><br>这个函数会使传入的信号量dsema的值减1；函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout，如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句</li>
<li><strong>dispatch_semaphore_signal(dispatch_semaphore_t dsema)</strong><br>使传入的信号量dsema的值加1</li>
</ol>
</blockquote>
<h4 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h4><p>OSSpinLock 自旋锁。使用时需要在头文件中导入：<strong>#import <libkern osatomic.h=""></libkern></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">__block OSSpinLock  spinLock = OS_SPINLOCK_INIT;</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue.next&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">    OSSpinLockLock(&amp;spinLock);</div><div class="line">     NSLog(@&quot;线程同步的操作1开始&quot;);</div><div class="line">     NSLog(@&quot;%f&quot;,CFAbsoluteTimeGetCurrent()*1000);</div><div class="line">     sleep(2);</div><div class="line">     NSLog(@&quot;线程同步的操作2结束&quot;);</div><div class="line">     OSSpinLockUnlock(&amp;spinLock);</div><div class="line">&#125;);</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    </div><div class="line">    OSSpinLockLock(&amp;spinLock);</div><div class="line">     NSLog(@&quot;线程同步的操作2开始&quot;);</div><div class="line">     NSLog(@&quot;%f&quot;,CFAbsoluteTimeGetCurrent() *1000);</div><div class="line">     dispatch_group_leave(group);</div><div class="line">     OSSpinLockUnlock(&amp;spinLock);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>OSSpinLock 性能最高的锁。原理很简单，就是一直 do while 循环。缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客说明了<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">OSSpinLock已经不再安全</a></p>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>测试如下（iPhone6、iOS9、1000000次）：测试数据不太准确，只能做一个相对的参考</p>
<blockquote>
<p><strong>@synchronized</strong>: 373.12 ms<br><strong>NSLock</strong>: 176.14 ms<br><strong>NSRecursiveLock</strong>: 158.24 ms<br><strong>NSConditionLock</strong>: 490.04 ms<br><strong>NSCondition</strong>: 193.38 ms<br><strong>pthread_mutex</strong>: 179.36 ms<br><strong>dispatch_semaphore</strong>: 58.20 ms<br><strong>OSSpinLock</strong>: 45.15 ms</p>
</blockquote>
<p>OSSpinLock和dispatch_semaphore的效率较高，@synchronized和NSConditionLock效率较差。由于OSSpinLock不安全，建议使用dispatch_semaphore</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;说到多线程就不得不说线程中的锁机制，多线程操作过程中往往多个线程是并发执行的。也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件和同一个方法等。因此当多个线程访问同一块资源时，很容易会发生数据错误及数据不安全等问题。因此要避免这些问题，需要使用“线程锁”来实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码阅读</title>
    <link href="http://chaosyuan.github.io/2016/04/03/2016-04-03-sdwebimageyuan-ma-yue-du/"/>
    <id>http://chaosyuan.github.io/2016/04/03/2016-04-03-sdwebimageyuan-ma-yue-du/</id>
    <published>2016-04-03T08:02:07.000Z</published>
    <updated>2016-08-19T02:00:25.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a>强大的网络图片加载库，以前只是能够灵活使用，对底层的实现原理，也是知其然而不知其所以然，但是成为一名优秀的开发者来说，会用只是最简单的一步，更重要的是要研究其底层的技术实现和设计思路原理。这个月工作也不忙，所以阅读下类库源码。记录下自己的思考与总结。</p>
<a id="more"></a>
<h4 id="SDWebImage-简介"><a href="#SDWebImage-简介" class="headerlink" title="SDWebImage 简介"></a>SDWebImage 简介</h4><blockquote>
<ol>
<li>提供UIImageView的一个分类，用来加载网络图片并且对网络图片的缓存进行管理</li>
<li>采用异步方式来下载网络图片</li>
<li>采用异步方式，使用memory＋disk来缓存网络图片，自动管理缓存</li>
<li>支持GIF动画</li>
<li>支持WebP格式</li>
<li>后台图片解压缩处理</li>
<li>确保同一个URL的图片不被重复下载</li>
<li>失效的URL不会被无限重试</li>
<li>下载及缓存时，主线程不被阻塞</li>
</ol>
</blockquote>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>在SDWebImage中,图片的下载是由SDWebImageDownloader类来完成的,它是一个异步的下载器。并且对图片的加载做了优化处理。</p>
<h5 id="下载选项"><a href="#下载选项" class="headerlink" title="下载选项"></a>下载选项</h5><p>在下载的过程中，程序会根据设置的不同的下载选项，而执行不同操作。下载选项由枚举<strong>SDWebImageDownloaderOptions</strong>定义，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageDownloaderOptions) &#123;</div><div class="line">    // 默认的使用模式,前往下载,返回进度block信息,完成时调用completedBlock</div><div class="line">    SDWebImageDownloaderLowPriority = 1 &lt;&lt; 0,</div><div class="line">    // 渐进式下载,如果设置了这个选项,会在下载过程中,每次接收到一段返回数据就会调用一次完成回调,回调中的image参数为未下载完成的部分图像,可以实现将图片一点点显示出来的功能</div><div class="line">    SDWebImageDownloaderProgressiveDownload = 1 &lt;&lt; 1,</div><div class="line"></div><div class="line">    // 默认情况下请求不使用NSURLCache，如果设置该选项，则以默认的缓存策略来使用NSURLCache</div><div class="line">    SDWebImageDownloaderUseNSURLCache = 1 &lt;&lt; 2,</div><div class="line">    </div><div class="line">    // 如果从NSURLcache缓存中读取图片，则在调用完成block的时候,传递空的image或者imageData</div><div class="line">    SDWebImageDownloaderIgnoreCachedResponse = 1 &lt;&lt; 3,</div><div class="line"></div><div class="line">    // 在iOS 4+系统上，允许程序进入后台后继续下载图片。该操作通过向系统申请额外时间来完成后台下载。如果后台任务终止，则操作将被取消</div><div class="line">    SDWebImageDownloaderContinueInBackground = 1 &lt;&lt; 4,</div><div class="line"></div><div class="line">    // 通过设置NSMutableURLRequest.HTTPShouldHandleCookies = YES来处理存储在NSHTTPCookieStore中的cookie</div><div class="line">    SDWebImageDownloaderHandleCookies = 1 &lt;&lt; 5,</div><div class="line"></div><div class="line">    // 允许不受信任的SSL证书。主要用于测试目的（生产环境慎用）</div><div class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = 1 &lt;&lt; 6,</div><div class="line"></div><div class="line">    // 将图片下载放到高优先级队列中</div><div class="line">    SDWebImageDownloaderHighPriority = 1 &lt;&lt; 7,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>选项涉及了下载优先级，缓存策略，后台运行，cookie处理及认证</p>
<h5 id="下载选项-1"><a href="#下载选项-1" class="headerlink" title="下载选项"></a>下载选项</h5><p>SDWebImage定义了两种下载顺序，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, SDWebImageDownloaderExecutionOrder) &#123;</div><div class="line"> </div><div class="line">    // 默认下载顺序 以队列的方式，按照先进先出的顺序下载</div><div class="line">    SDWebImageDownloaderFIFOExecutionOrder,</div><div class="line"></div><div class="line">    // 以栈的方式，按照后进先出的顺序下载</div><div class="line">    SDWebImageDownloaderLIFOExecutionOrder</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h5 id="下载管理器"><a href="#下载管理器" class="headerlink" title="下载管理器"></a>下载管理器</h5><p>SDWebImageDownloader下载管理器是一个单例类，主要管理图片的下载操作。图片的下载是放在NSOperationQueue操作队列中来完成的，队列的默认最大并发数为6.设置超时时间为15s.</p>
<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的，其声明及定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (SDDispatchQueueSetterSementics, nonatomic) dispatch_queue_t barrierQueue;</div><div class="line"></div><div class="line">_barrierQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageDownloaderBarrierQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<h5 id="下载回调"><a href="#下载回调" class="headerlink" title="下载回调"></a>下载回调</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 下载进度(返回已经接收的图片数据的大小,未接收的图片数据的大小)</div><div class="line">typedef void(^SDWebImageDownloaderProgressBlock)(NSInteger receivedSize, NSInteger expectedSize);</div><div class="line">// 下载完成</div><div class="line">typedef void(^SDWebImageDownloaderCompletedBlock)(UIImage *image, NSData *data, NSError *error, BOOL finished);</div><div class="line">// Header 过滤</div><div class="line">typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);</div></pre></td></tr></table></figure>
<p>图片下载的回调信息存储在<strong>URLCallbacks</strong>属性里面。该属性是一个字典。key是图片的URL地址，value则是一个数组，包含每个图片的多组回调信息。value(数组里面)只包含一个元素,这个元素的类型是NSMutableDictionary类型,这个字典的key为NSString类型代表着回调类型,value为block,是对应的回调。目的都是为了给url绑定回调。由于允许多个图片同时下载，因此可能会有多个线程同时操作URLCallbacks属性。为了保证线程安全。将下载操作作为一个个任务放到barrierQueue队列中。并设置栅栏来确保同一时间只有一个线程操作URLCallbacks属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</div><div class="line"></div><div class="line">  // 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作</div><div class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</div><div class="line">    </div><div class="line"> // 处理同一URL的同步下载请求的单个下载</div><div class="line">        NSMutableArray *callbacksForURL = self.URLCallbacks[url];</div><div class="line">        NSMutableDictionary *callbacks = [NSMutableDictionary new];</div><div class="line">        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</div><div class="line">        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</div><div class="line">        [callbacksForURL addObject:callbacks];</div><div class="line">        self.URLCallbacks[url] = callbacksForURL;</div><div class="line">// 如果url第一次绑定它的回调,也就是第一次使用这个url创建下载任务则执行一次创建回调</div><div class="line">        if (first) &#123;</div><div class="line">            createCallback();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在barrierQueue队列中创建下载任务。至此下载的任务都创建好了,下面到下载的操作了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">   - (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url </div><div class="line">                                         options:(SDWebImageDownloaderOptions)options </div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line"></div><div class="line">            __block SDWebImageDownloaderOperation *operation;</div><div class="line">            [self addProgressCallback:progressBlock </div><div class="line">                       completedBlock:completedBlock </div><div class="line">                               forURL:url </div><div class="line">                        createCallback:^&#123;</div><div class="line">         NSTimeInterval timeoutInterval = wself.downloadTimeout;</div><div class="line">       if (timeoutInterval == 0.0) &#123;</div><div class="line">         timeoutInterval = 15.0;</div><div class="line">       &#125;</div><div class="line">      // 1. 创建请求对象，并根据options参数设置其属性</div><div class="line">      // 为了避免潜在的重复缓存(NSURLCache + SDImageCache)，如果没有明确告知需要缓存，则禁用图片请求的缓存操作</div><div class="line">  NSMutableURLRequest *request = </div><div class="line">[[NSMutableURLRequest alloc] initWithURL:url </div><div class="line">cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) </div><div class="line">timeoutInterval:timeoutInterval];</div><div class="line"></div><div class="line">// 通过设置 NSMutableURLRequest.HTTPShouldHandleCookies = YES的方式来处理存储在NSHTTPCookieStore的cookies</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">//返回在接到上一个请求得得响应之前,需要传输数据,YES传输,NO不传输</div><div class="line">        request.HTTPShouldUsePipelining = YES;</div><div class="line">  &#125;];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">/**</div><div class="line">如果自定义了wself.headersFilter,那就用自己设置的</div><div class="line">wself.headersFilter来设置HTTP的header field</div><div class="line">它的定义是typedef NSDictionary *(^SDWebImageDownloaderHeadersFilterBlock)(NSURL *url, NSDictionary *headers);</div><div class="line">一个返回结果为NSDictionary类型的block</div><div class="line"></div><div class="line">如果没有自己设置wself.headersFilter那么就用SDWebImage提供的HTTPHeaders</div><div class="line">HTTPHeaders在#import &quot;SDWebImageDownloader.h&quot;,init方法里面初始化,下载webp图片需要的header不一样</div><div class="line">#ifdef SD_WEBP</div><div class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/webp,image/*;q=0.8&quot;&#125; mutableCopy];</div><div class="line">#else</div><div class="line">        _HTTPHeaders = [@&#123;@&quot;Accept&quot;: @&quot;image/*;q=0.8&quot;&#125; mutableCopy];</div><div class="line">#endif</div><div class="line">*/</div><div class="line">  if (wself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">/**</div><div class="line">创建SDWebImageDownLoaderOperation操作对象(下载的操作就是在SDWebImageDownLoaderOperation类里面进行的)</div><div class="line">传入了进度回调,完成回调,取消回调</div><div class="line">*/</div><div class="line">    operation = [[wself.operationClass alloc] initWithRequest:request</div><div class="line">                                                          options:options</div><div class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</div><div class="line">                                                          SDWebImageDownloader *sself = wself;</div><div class="line">                                                             if (!sself) return;</div><div class="line">                                                             __block NSArray *callbacksForURL;</div><div class="line">dispatch_sync(sself.barrierQueue, ^&#123;</div><div class="line">           // 从管理器的callbacksForURL中找出该URL所有的进度处理回调并调用</div><div class="line">                callbacksForURL = [sself.URLCallbacks[url] copy];</div><div class="line">        &#125;);</div><div class="line">  for (NSDictionary *callbacks in callbacksForURL) &#123;</div><div class="line">       dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">      SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</div><div class="line">     if (callback) callback(receivedSize, expectedSize);</div><div class="line">          &#125;);</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">    completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</div><div class="line">        // 从管理器的callbacksForURL中找出该URL所有的完成处理回调并调用，</div><div class="line">                     SDWebImageDownloader *sself = wself;</div><div class="line">                     if (!sself) return;</div><div class="line">                     __block NSArray *callbacksForURL;</div><div class="line">                     dispatch_barrier_sync(sself.barrierQueue, ^&#123;</div><div class="line">                         callbacksForURL = [sself.URLCallbacks[url] copy];</div><div class="line">                       if (finished) &#123;</div><div class="line">        // 如果这个任务已经完成,就根据url这个key从URLCallbacks字典里面删除</div><div class="line">                                     [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                        &#125;</div><div class="line">                                         &#125;);</div><div class="line">         for (NSDictionary *callbacks in callbacksForURL) &#123;</div><div class="line">                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</div><div class="line">             if (callback) callback(image, data, error, finished);</div><div class="line">                                                            &#125;</div><div class="line">                                                        &#125;</div><div class="line">                                                        cancelled:^&#123;</div><div class="line">  // 取消操作将该url对应的回调信息从URLCallbacks中删除  </div><div class="line">   SDWebImageDownloader *sself = wself;</div><div class="line">   if (!sself) return;                                                                                                                                                              dispatch_barrier_async(sself.barrierQueue, ^&#123;                                                               [sself.URLCallbacks removeObjectForKey:url];</div><div class="line">                                                           &#125;);</div><div class="line">                                                        &#125;];</div><div class="line"></div><div class="line"> // 设置是否需要解压</div><div class="line"> operation.shouldDecompressImages = wself.shouldDecompressImages;</div><div class="line">       if (wself.urlCredential) &#123;</div><div class="line">            operation.credential = wself.urlCredential;</div><div class="line">        &#125; else if (wself.username &amp;&amp; wself.password) &#123;</div><div class="line">            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</div><div class="line">        &#125;   </div><div class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</div><div class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</div><div class="line">        &#125;</div><div class="line">//  将操作加入到操作队列downloadQueue中.如果是LIFO顺序，则将新的操作作为原队列中最后一个操作的依赖，然后将新操作设置为最后一个操作</div><div class="line">        [wself.downloadQueue addOperation:operation];</div><div class="line">        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            [wself.lastAddedOperation addDependency:operation];</div><div class="line">            wself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">    return operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="下载操作"><a href="#下载操作" class="headerlink" title="下载操作"></a>下载操作</h5><p>每个图片的下载都是一个Operation操作。SDWebImage自定义了一个SDWebImageDownloaderOperation类,继承自NSOperation。并遵守<strong>SDWebImageOperation</strong>协议。对于图片的下载。使用的是NSURLConnection(未使用7.0以后的NSURLSession)。在SDWebImageDownloaderOperation中重写了<strong>start</strong>方法，方便自己管理下载的状态。此方法是执行下载任务的核心代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">- (void)start &#123;</div><div class="line">    @synchronized (self) &#123;</div><div class="line">      // 管理下载状态，如果已取消，则重置当前下载并设置完成状态为YES</div><div class="line">        if (self.isCancelled) &#123;</div><div class="line">            self.finished = YES;</div><div class="line">            [self reset];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</div><div class="line">        // 如果设置了在后台执行，则进行后台执行</div><div class="line">        if ([self shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __weak __typeof__ (self) wself = self;</div><div class="line">            self.backgroundTaskId = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                ...</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">        self.executing = YES;</div><div class="line">        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];</div><div class="line">        self.thread = [NSThread currentThread];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self.connection start];</div><div class="line"></div><div class="line">    if (self.connection) &#123;</div><div class="line">        if (self.progressBlock) &#123;</div><div class="line">            self.progressBlock(0, NSURLResponseUnknownLength);</div><div class="line">        &#125;</div><div class="line">        // 在主线程中发送开始下载的通知</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];</div><div class="line">        &#125;);</div><div class="line">/**</div><div class="line">在[self.connection start];有返回结果之前,代码会一直阻塞在CFRunLoopRun这里，也就是说下载就一直在进行中,一直到下载完成或者错误(这两种情况都会调用CFRunLoopStop),阻塞才会解除</div><div class="line">*/</div><div class="line">        // 开启当前线程的runloop</div><div class="line">        if (floor(NSFoundationVersionNumber) &lt;= NSFoundationVersionNumber_iOS_5_1) &#123;</div><div class="line">            CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, false);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            CFRunLoopRun();</div><div class="line">        &#125;</div><div class="line">        // 如果未完成，则取消连接</div><div class="line">        if (!self.isFinished) &#123;</div><div class="line">            [self.connection cancel];</div><div class="line">            [self connection:self.connection didFailWithError:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorTimedOut userInfo:@&#123;NSURLErrorFailingURLErrorKey : self.request.URL&#125;]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">   //如果connection创建失败,直接执行完成回调,并传递一个connection没有初始化的错误</div><div class="line">        if (self.completedBlock) &#123;</div><div class="line">            self.completedBlock(nil, nil, [NSError errorWithDomain:NSURLErrorDomain code:0 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Connection can&apos;t be initialized&quot;&#125;], YES);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">// 下载操作已经完成了,停止在后台的执行,使用endBackgroundTask</div><div class="line">#if TARGET_OS_IPHONE &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_4_0</div><div class="line">    if (self.backgroundTaskId != UIBackgroundTaskInvalid) &#123;</div><div class="line">        [[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskId];</div><div class="line">        self.backgroundTaskId = UIBackgroundTaskInvalid;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要看一下connection: didReceiveData拼接数据的协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</div><div class="line">    // 拼接数据</div><div class="line">    [self.imageData appendData:data];</div><div class="line"></div><div class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock) &#123;</div><div class="line"></div><div class="line">        // 获取已接收的数据的长度</div><div class="line">        const NSInteger totalSize = self.imageData.length;</div><div class="line"></div><div class="line">        // 每次接收到数据时,都会用现有的数据创建一个CGImageSourceRef对象以做处理,而且这个数据应该是已接收的全部数据,而不仅仅是新的字节</div><div class="line">        CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);</div><div class="line"></div><div class="line">        /**</div><div class="line">在首次接收到数据的时候,图片的长宽都是0(width+height == 0)</div><div class="line">先从这些包含图像信息的数据中取出图像的长,宽,方向等信息以备使用</div><div class="line">*/</div><div class="line">        if (width + height == 0) &#123;</div><div class="line">            CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);</div><div class="line">            if (properties) &#123;</div><div class="line">                NSInteger orientationValue = -1;</div><div class="line">                CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</div><div class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height);</div><div class="line">                ...</div><div class="line">                CFRelease(properties);</div><div class="line"></div><div class="line">                          /**</div><div class="line">                使用Core Craphics框架绘制image时,使用的是</div><div class="line">                initWithCGImage这个函数,但是使用这个函数有时候会造成图片朝向的错误,所以在这里保存朝向信息,orientation是一个可以记录图片方向的枚举</div><div class="line">            */</div><div class="line">                orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 图片还未接收完全</div><div class="line">        if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) &#123;</div><div class="line">            // 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张</div><div class="line">            CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);</div><div class="line"></div><div class="line">#ifdef TARGET_OS_IPHONE</div><div class="line">            // 对下载下来的图片做个颜色空间转换等处理</div><div class="line">            if (partialImageRef) &#123;</div><div class="line">                const size_t partialHeight = CGImageGetHeight(partialImageRef);</div><div class="line">                CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</div><div class="line">                CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</div><div class="line">                CGColorSpaceRelease(colorSpace);</div><div class="line"></div><div class="line">                if (bmContext) &#123;</div><div class="line">                    CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</div><div class="line">                    CGImageRelease(partialImageRef);</div><div class="line">                    partialImageRef = CGBitmapContextCreateImage(bmContext);</div><div class="line">                    CGContextRelease(bmContext);</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    CGImageRelease(partialImageRef);</div><div class="line">                    partialImageRef = nil;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">            // 对图片进行缩放、解码操作</div><div class="line">            if (partialImageRef) &#123;</div><div class="line">                UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];</div><div class="line">                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</div><div class="line">                UIImage *scaledImage = [self scaledImageForKey:key image:image];</div><div class="line">                image = [UIImage decodedImageWithImage:scaledImage];</div><div class="line">                CGImageRelease(partialImageRef);</div><div class="line">                dispatch_main_sync_safe(^&#123;</div><div class="line">                    if (self.completedBlock) &#123;</div><div class="line">                        self.completedBlock(image, nil, nil, NO);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        CFRelease(imageSource);</div><div class="line">    &#125;</div><div class="line">    if (self.progressBlock) &#123;</div><div class="line">        self.progressBlock(self.imageData.length, self.expectedSize);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下载的核心是利用NSURLConnection对象来加载数据。每个图片的下载都由一个Operation操作来完成，并将这些操作放到一个操作队列中。这样可以实现图片的并发下载。之前在做<a href="https://itunes.apple.com/us/app/hao-chang-yi-miao-bian-ge-shen/id788432982?ls=1&amp;mt=8" target="_blank" rel="external">好唱</a>项目时，伴奏的下载也是采用这用设计思路。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>SDWebImage提供了对图片缓存的支持，而该功能是由SDImageCache类来完成的。该类负责处理内存缓存及磁盘缓存。其中磁盘缓存的写操作是异步的。</p>
<h5 id="内存缓存"><a href="#内存缓存" class="headerlink" title="内存缓存"></a>内存缓存</h5><p>NSCache是一个类似于集合的容器,即缓存。它存储key-value,这一点非常类似 NSDictionary。 一般用 NSCache来缓存临时存储短时间但是使用创建成本高的对象,重用这些对象可以优化性能,因为他们的值不需要被重新计算。另外一方面,这些对象对于程序来说是不要紧的,在内存紧张的时候会被丢弃,如果对象被丢弃了,则下次使用的时候需要重新计算</p>
<h5 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h5><p>磁盘缓存则是使用NSFileManager对象来实现的。图片存储的位置是位于Cache文件夹。此外SDImageCache还定义了一个串行队列，来异步存储图片</p>
<h5 id="图片存储"><a href="#图片存储" class="headerlink" title="图片存储"></a>图片存储</h5><p>在iOS中，会先检测图片是PNG还是JPEG，并将其转换为相应的图片数据，最后将数据写入到磁盘中。判断是否是png格式的文件，除了看是不是.png后缀格式命名外，还能分析文件开头的部分数据，这部分数据就是文件签名，每个标准的PNG文件开头都有固定格式的数字签名。<a href="http://blog.csdn.net/benny5609/article/details/2143023" target="_blank" rel="external">详细参考</a>文件名的命名规则则是按照缓存的key做md5处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (NSString *)cachedFileNameForKey:(NSString *)key &#123;</div><div class="line">    const char *str = [key UTF8String];</div><div class="line">    if (str == NULL) &#123;</div><div class="line">        str = &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</div><div class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</div><div class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</div><div class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</div><div class="line">                          r[11], r[12], r[13], r[14], r[15], [[key pathExtension] isEqualToString:@&quot;&quot;] ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, [key pathExtension]]];</div><div class="line"></div><div class="line">    return filename;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当查询图片时，该操作会在内存中放置一份缓存，如果确定需要缓存到磁盘，则将磁盘缓存操作作为一个task放到串行队列中处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</div><div class="line">    if (!image || !key) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (self.shouldCacheImagesInMemory) &#123;</div><div class="line">    // //查询图片大小，并存入内存(NSCache)中</div><div class="line">        NSUInteger cost = SDCacheCostForImage(image);</div><div class="line">        [self.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line">// 加载到磁盘</div><div class="line">    if (toDisk) &#123;</div><div class="line">        dispatch_async(self.ioQueue, ^&#123;</div><div class="line">            NSData *data = imageData;</div><div class="line">// 是否要重新处理图片数据</div><div class="line">            if (image &amp;&amp; (recalculate || !data)) &#123;</div><div class="line">#if TARGET_OS_IPHONE</div><div class="line">// 确定图片是png还是jpeg. imageData为nil的话当做是png处理</div><div class="line">                int alphaInfo = CGImageGetAlphaInfo(image.CGImage);</div><div class="line">                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                                  alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                                  alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">                BOOL imageIsPng = hasAlpha;</div><div class="line">                if ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</div><div class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (imageIsPng) &#123;</div><div class="line">                    data = UIImagePNGRepresentation(image);</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);</div><div class="line">                &#125;</div><div class="line">#else</div><div class="line">                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];</div><div class="line">#endif</div><div class="line">            &#125;</div><div class="line">// 创建缓存文件并存储图片</div><div class="line">            [self storeImageDataToDisk:data forKey:key];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="图片查询"><a href="#图片查询" class="headerlink" title="图片查询"></a>图片查询</h5><p>使用key作为参数，查询内存和磁盘中是否有对应的图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)imageFromMemoryCacheForKey:(NSString *)key;</div><div class="line">- (UIImage *)imageFromDiskCacheForKey:(NSString *)key;</div></pre></td></tr></table></figure>
<h5 id="图片移除"><a href="#图片移除" class="headerlink" title="图片移除"></a>图片移除</h5><p>使用如下操作可以移除内存或者磁盘上的图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)removeImageForKey:(NSString *)key;</div><div class="line">- (void)removeImageForKey:(NSString *)key withCompletion:(SDWebImageNoParamsBlock)completion;</div><div class="line">- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk;</div><div class="line">- (void)removeImageForKey:(NSString *)key fromDisk:(BOOL)fromDisk withCompletion:(SDWebImageNoParamsBlock)completion;</div></pre></td></tr></table></figure></p>
<h5 id="图片清理"><a href="#图片清理" class="headerlink" title="图片清理"></a>图片清理</h5><p>两种清理方式：<strong>完全清空</strong>和<strong>部分清空</strong></p>
<p>完全清空是直接把文件夹移除掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)clearMemory</div><div class="line">- (void)clearDiskOnCompletion:(SDWebImageNoParamsBlock)completion</div></pre></td></tr></table></figure>
<p>部分清空是根据参数配置、移除文件。使文件的总大小小于最大使用空间。清理策略有两个文件缓存的有限期时间及最大缓存空间大小。<br><strong>文件的缓存有效期</strong>：默认是一周。如果文件的缓存时间超过这个时间值，则将其移除<br><strong>最大缓存空间大小</strong>：如果所有缓存文件的总大小超过最大缓存空间，则会按照文件最后修改时间的逆序，以每次一半的递归来移除那些过早的文件，直到缓存的实际大小小于我们设置的最大使用空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    dispatch_async(self.ioQueue, ^&#123;</div><div class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</div><div class="line">        NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</div><div class="line"></div><div class="line">        // 通过文件的枚举器来获取缓存文件的有用的属性</div><div class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:resourceKeys</div><div class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</div><div class="line">                                                                 errorHandler:NULL];</div><div class="line"></div><div class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];</div><div class="line">        NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];</div><div class="line">        NSUInteger currentCacheSize = 0;</div><div class="line">        // 枚举缓存文件夹中所有文件,移除过期的文件,存储文件属性便后面清理</div><div class="line">        NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];</div><div class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</div><div class="line">            NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];</div><div class="line"></div><div class="line">            // 忽略文件夹</div><div class="line">            if ([resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 移除过期文件</div><div class="line">            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</div><div class="line">            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">                [urlsToDelete addObject:fileURL];</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 存储文件的引用并计算所有文件的总大小，以备后用</div><div class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">            currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</div><div class="line">            [cacheFiles setObject:resourceValues forKey:fileURL];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</div><div class="line">            [_fileManager removeItemAtURL:fileURL error:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">       // 如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，首先删除最老的文件</div><div class="line">        if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) &#123;</div><div class="line">        // 以设置的最大缓存大小的一半作为清理目标</div><div class="line">            const NSUInteger desiredCacheSize = self.maxCacheSize / 2;</div><div class="line"></div><div class="line">            // 剩下的缓存文件按照最后修改时间来排序</div><div class="line">            NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</div><div class="line">                                                            usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</div><div class="line">                                                                return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</div><div class="line">                                                            &#125;];</div><div class="line"></div><div class="line">            // 删除文件，直到缓存总大小降到我们期望的大小</div><div class="line">            for (NSURL *fileURL in sortedFiles) &#123;</div><div class="line">                if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123;</div><div class="line">                    NSDictionary *resourceValues = cacheFiles[fileURL];</div><div class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</div><div class="line">                    currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</div><div class="line"></div><div class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (completionBlock) &#123;</div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于缓存操作总结：</p>
<blockquote>
<ol>
<li>缓存分为内存缓存和磁盘缓存（以NSCache和文件的形式） </li>
<li>读取先从内存查找、如果没有再从磁盘读取并放入内存</li>
<li>提供完全移除和部分移除功能，部分移除根据配置、达到删除文件后的容量小于用户设定的最大值</li>
</ol>
</blockquote>
<h4 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface SDWebImageManager : NSObject</div><div class="line">@property (weak, nonatomic) id &lt;SDWebImageManagerDelegate&gt; delegate;</div><div class="line">@property (strong, nonatomic, readonly) SDImageCache *imageCache;</div><div class="line">@property (strong, nonatomic, readonly) SDWebImageDownloader *imageDownloader;</div></pre></td></tr></table></figure>
<p>在开发应用中，SDWebImageManager 管理图片的<strong>下载</strong>和<strong>缓存</strong>，所以提供了<strong>SDImageCache</strong>和<strong>SDWebImageDownloader</strong>两个类的属性，我们经常用到的诸如UIImageView+WebCache等控件的分类都是基于SDWebImageManager对象的。SDWebImageManagerDelegate还声明了两个可选实现的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 缓存图片没有找到的时候，去哪里下载</div><div class="line">- (BOOL)imageManager:(SDWebImageManager *)imageManager shouldDownloadImageForURL:(NSURL *)imageURL;</div><div class="line"></div><div class="line">// 允许在图片已经被下载完成且被缓存到磁盘或内存前立即转换</div><div class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</div></pre></td></tr></table></figure>
<p>在查看源码时，发现了有趣的宏定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#define dispatch_main_sync_safe(block)\</div><div class="line">    if ([NSThread isMainThread]) &#123;\</div><div class="line">        block();\</div><div class="line">    &#125; else &#123;\</div><div class="line">        dispatch_sync(dispatch_get_main_queue(), block);\</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#define dispatch_main_async_safe(block)\</div><div class="line">    if ([NSThread isMainThread]) &#123;\</div><div class="line">        block();\</div><div class="line">    &#125; else &#123;\</div><div class="line">        dispatch_async(dispatch_get_main_queue(), block);\</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>保证了在主线程执行。</p>
<h4 id="补充点"><a href="#补充点" class="headerlink" title="补充点"></a>补充点</h4><p>之前一直不明白，为什么将图片从磁盘读取出来后需要做Decode，后来<a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">参考</a><br>才明白。由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。这是典型的空间换时间的做法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;强大的网络图片加载库，以前只是能够灵活使用，对底层的实现原理，也是知其然而不知其所以然，但是成为一名优秀的开发者来说，会用只是最简单的一步，更重要的是要研究其底层的技术实现和设计思路原理。这个月工作也不忙，所以阅读下类库源码。记录下自己的思考与总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP缓存策略</title>
    <link href="http://chaosyuan.github.io/2016/03/27/2016-03-27-httphuan-cun-ce-lue/"/>
    <id>http://chaosyuan.github.io/2016/03/27/2016-03-27-httphuan-cun-ce-lue/</id>
    <published>2016-03-27T11:00:22.000Z</published>
    <updated>2016-08-23T05:57:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>最近在开发公司<a href="https://www.jucaifu.com/" target="_blank" rel="external">web</a>时，对HTTP缓存不是很了解，之后仔细看了HTTP缓存策略.记录下来。浏览器一般缓存图片、CSS、JS等静态文件，因为这些文件的更新频率相对来说比较低，合理利用浏览器的缓存可以优化网站性能，提升体验。</p>
<a id="more"></a>
<h4 id="HTTP协议-Header"><a href="#HTTP协议-Header" class="headerlink" title="HTTP协议(Header)"></a>HTTP协议(Header)</h4><p>HTTP缓存主要由HTTP协议的头（Header）信息来制定，缓存分为两部分，分别是本地缓存和缓存协商。在介绍缓存之前，先说一下服务端Header 取值</p>
<blockquote>
<p>Expires：后面跟一个绝对时间字符串，表示文档在浏览器中的过期时间.比如：Mon, 22 Jun 2026 01:05:00 GMT。</p>
<p>Cache-Control：除了提供了同Expires相同并更精确的缓存功能，还提供了验证机制，它可以取以下这些值：<br>max-age：功能和Expires类似，但是后面跟一个以“秒”为单位的相对时间，来供浏览器计算过期时间。<br>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。<br>no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。<br>private：表示只有用户客户端可以缓存，而 CDN 等不可。<br>public：表示用户客户端和 CDN 都可以缓存当前资源。</p>
</blockquote>
<p>需要注意：如果同时出现Cache-Control和Expires，Cache-Control的优先级要高于Expires</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Cache-Control: max-age=315360000</div><div class="line">Expires: Tue, 16 Jun 2026 07:30:16 GMT</div></pre></td></tr></table></figure>
<h4 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h4><p>本地缓存是指当浏览器请求资源时，如果命中了浏览器本地的缓存资源，那么浏览器就不会发送真正请求给服务器。它的执行过程如下：</p>
<ol>
<li>浏览器第一次发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来</li>
<li>浏览器第二次准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，如果下次请求时间没有超过缓存过期时间，浏览器会直接命中本地缓存，而不会向浏览器发送请求。</li>
<li>如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段</li>
</ol>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/bendihuancun.png" alt="enter image description here"></p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>当第一次请求时服务器返回的响应头中没有Cache-Control和Expires或者Cache-Control和Expires过期或者它的属性设置为no-cache时，那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok。</p>
<p>服务器通过2种方式来判断浏览器缓存是否是最新的</p>
<h5 id="1-Last-Modified与If-Modified-Since"><a href="#1-Last-Modified与If-Modified-Since" class="headerlink" title="1.Last-Modified与If-Modified-Since"></a>1.Last-Modified与If-Modified-Since</h5><p>当浏览器第一次请求资源时，服务器会把资源的最新修改时间<strong>Last-Modified: Mon, 04 March 2016 09:13:50 GMT</strong>放在响应头中返回给浏览器，第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头<strong>If-Modified-Since:Last-Modified: Mon, 04 March 2016 09:13:50 GMT</strong>发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比，如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时Last-Modified头也不会返回，因为资源没有被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同Last-Modified头一起返回。</p>
<p>这种方式是通过头信息资源的修改时间来判断资源有没有更新。当然这种方式有一定的弊端。比如：</p>
<ol>
<li>Last-Modified的日期只能精确到秒，如果在1s内做了修改，那么就会出现错误判断</li>
<li>如果一些资源定期生成，这种情况下内容没有变化但是服务器的 Last-Modified改变了，导致使用不了缓存</li>
</ol>
<p>另一种方式就是根据资源的内容来判断，就是ETag与If-None-Match</p>
<h5 id="2-ETag-If-None-Match"><a href="#2-ETag-If-None-Match" class="headerlink" title="2.ETag/If-None-Match"></a>2.ETag/If-None-Match</h5><p>首先说一下Etag，Etag是资源在服务器的唯一标识符，能够更加准确的控制缓存。其实这种方式和Last-Modified与If-Modified-Since流程是相似的。唯一的区别是它基于资源的内容的摘要信息（比如MD5 hash）来判断。浏览器发送第二次请求时，会把第一次的响应头信息ETag的值放在If-None-Match的请求头中发送到服务器，与最新的资源的摘要信息进行对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用ETag的好处是如果因为某种原因到时资源的修改时间没改变，那么用ETag就能区分资源是不是有被更新。</p>
<p>Last-Modified 与 ETag 是可以一起使用的，当两者同时存在的时候,通过以下表达式来进行缓存策略的判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if ETagFromServer != ETagOnClient || LastModifiedFromServer != LastModifiedOnClient</div><div class="line">   GetFromServer</div><div class="line">else</div><div class="line">   GetFromCache</div></pre></td></tr></table></figure>
<p>参考： <a href="http://stackoverflow.com/questions/824152/what-takes-precedence-the-etag-or-last-modified-http-header" target="_blank" rel="external">StackOverflow-What takes precedence: the ETag or Last-Modified HTTP header?</a></p>
<hr>
<p><strong>Request</strong></p>
<table>
<thead>
<tr>
<th>Cache-Control: max-age=31536</th>
<th style="text-align:center">以秒为单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>If-Modified-Since:”Mon, 04 March 2016 10:38:50 GMT”</td>
<td style="text-align:center">缓存文件的最后修改时间</td>
</tr>
<tr>
<td>If-None-Match:”0693f78a437cc1:0”</td>
<td style="text-align:center">缓存文件的ETag 值</td>
</tr>
<tr>
<td>Cache-Control:no-cache</td>
<td style="text-align:center">不使用缓存</td>
</tr>
</tbody>
</table>
<p><strong>Response</strong></p>
<table>
<thead>
<tr>
<th>Cache-Control: max-age=60</th>
<th style="text-align:center">60秒过后缓存过期（相对时间）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data:”Mon, 04 March 2016 10:39:00 GMT”</td>
<td style="text-align:center">当前Response发送的时间</td>
</tr>
<tr>
<td>Expires:”Mon, 04 March 2016 10:40:00 GMT”</td>
<td style="text-align:center">缓存过期的时间（绝对时间）</td>
</tr>
<tr>
<td>Last-Modified:”Mon, 04 March 2016 10:38:50 GMT”</td>
<td style="text-align:center">服务器文件的最后修改时间</td>
</tr>
<tr>
<td>ETag:”20d3abb7ec1cd1:0”</td>
<td style="text-align:center">服务器文件的ETag值</td>
</tr>
</tbody>
</table>
<p>使用Ctrl+F5(Com+R) 强制刷新页面，可以忽略以上讲的两种缓存策略</p>
<table>
<thead>
<tr>
<th>操作</th>
<th style="text-align:center">Cache-Control</th>
<th style="text-align:center">Last-Modified/Etag</th>
</tr>
</thead>
<tbody>
<tr>
<td>前进后退</td>
<td style="text-align:center">有效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td>刷新-F5</td>
<td style="text-align:center">无效</td>
<td style="text-align:center">有效</td>
</tr>
<tr>
<td>强制刷新</td>
<td style="text-align:center">无效</td>
<td style="text-align:center">无效</td>
</tr>
</tbody>
</table>
<p>参考文献：</p>
<ol>
<li><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/" target="_blank" rel="external">http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="external">Web Fundamentals - Google Developers</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;最近在开发公司&lt;a href=&quot;https://www.jucaifu.com/&quot;&gt;web&lt;/a&gt;时，对HTTP缓存不是很了解，之后仔细看了HTTP缓存策略.记录下来。浏览器一般缓存图片、CSS、JS等静态文件，因为这些文件的更新频率相对来说比较低，合理利用浏览器的缓存可以优化网站性能，提升体验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="web" scheme="http://chaosyuan.github.io/tags/web/"/>
    
      <category term="HTTP" scheme="http://chaosyuan.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>CoreAnimation动画入门</title>
    <link href="http://chaosyuan.github.io/2016/03/19/2016-03-19-coreanimationdong-hua-ru-men/"/>
    <id>http://chaosyuan.github.io/2016/03/19/2016-03-19-coreanimationdong-hua-ru-men/</id>
    <published>2016-03-19T08:12:22.000Z</published>
    <updated>2016-08-22T11:03:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Core Animation是iOS与mac OS 平台上负责图形渲染与动画的基础框架。Core Animation可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用Core Animation的动画效果。Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，而且不会加重CPU的负担而影响程序的运行速度。</p>
<a id="more"></a>
<h4 id="Core-Animation类图"><a href="#Core-Animation类图" class="headerlink" title="Core Animation类图"></a>Core Animation类图</h4><p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/CoreAnimateClass.png" alt="Core Animation类图"></p>
<p>上图为Core Animation类图，可以大体可以分为如下几类:</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CAAnaimation</td>
<td style="text-align:center">抽象类，不具备动画效果，必须用它的子类才有动画效果</td>
</tr>
<tr>
<td style="text-align:center">CAPropertyAnimation</td>
<td style="text-align:center">抽象类，本身不具备动画效果，只有子类才有</td>
</tr>
<tr>
<td style="text-align:center">CABasicAnimation</td>
<td style="text-align:center">基本动画，做一些简单动画效果</td>
</tr>
<tr>
<td style="text-align:center">CAAnimaitionGroup</td>
<td style="text-align:center">动画组，可以同时进行缩放，旋转</td>
</tr>
<tr>
<td style="text-align:center">CAKeyFrameAnimation</td>
<td style="text-align:center">帧动画，做一些连续的流畅的动画</td>
</tr>
<tr>
<td style="text-align:center">CATrasition</td>
<td style="text-align:center">转场动画</td>
</tr>
</tbody>
</table>
<p>核心动画中所有类都遵守CAMediaTiming协议。</p>
<h4 id="CAAnimation-简介"><a href="#CAAnimation-简介" class="headerlink" title="CAAnimation 简介"></a>CAAnimation 简介</h4><h5 id="基本属性说明"><a href="#基本属性说明" class="headerlink" title="基本属性说明"></a>基本属性说明</h5><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">duration</td>
<td style="text-align:center">动画的持续时间</td>
</tr>
<tr>
<td style="text-align:center">beginTime</td>
<td style="text-align:center">指定动画开始时间。从开始指定延迟几秒执行的话，请设置为「CACurrentMediaTime() + 秒数」的形式</td>
</tr>
<tr>
<td style="text-align:center">repeatCount</td>
<td style="text-align:center">重复次数。永久重复设置为HUGE_VALF</td>
</tr>
<tr>
<td style="text-align:center">repeatDuration</td>
<td style="text-align:center">重复时间</td>
</tr>
<tr>
<td style="text-align:center">autoreverses</td>
<td style="text-align:center">动画结束时是否执行逆动画</td>
</tr>
<tr>
<td style="text-align:center">timingFunction</td>
<td style="text-align:center">动画的速度变化</td>
</tr>
<tr>
<td style="text-align:center">removedOnCompletion</td>
<td style="text-align:center">默认为YES，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为NO，不过还要设置fillMode为kCAFillModeForwards</td>
</tr>
<tr>
<td style="text-align:center">fillMode</td>
<td style="text-align:center">决定当前对象在非active时间段的行为。比如动画开始之前或者动画结束</td>
</tr>
</tbody>
</table>
<h5 id="fillMode属性说明"><a href="#fillMode属性说明" class="headerlink" title="fillMode属性说明"></a>fillMode属性说明</h5><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kCAFillModeRemoved</td>
<td style="text-align:center">默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态</td>
</tr>
<tr>
<td style="text-align:center">kCAFillModeForwards</td>
<td style="text-align:center">当动画结束后,layer会一直保持着动画最后的状态</td>
</tr>
<tr>
<td style="text-align:center">field1</td>
<td style="text-align:center">这个和kCAFillModeForwards是相对的,就是在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态,并等待动画开始</td>
</tr>
<tr>
<td style="text-align:center">kCAFillModeBoth</td>
<td style="text-align:center">动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态</td>
</tr>
</tbody>
</table>
<h5 id="CAMediaTimingFunction-速度控制"><a href="#CAMediaTimingFunction-速度控制" class="headerlink" title="CAMediaTimingFunction 速度控制"></a>CAMediaTimingFunction 速度控制</h5><table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kCAMediaTimingFunctionLinear（线性）</td>
<td style="text-align:center">匀速,相对静态的感觉</td>
</tr>
<tr>
<td style="text-align:center">kCAMediaTimingFunctionEaseIn（渐进）</td>
<td style="text-align:center">动画缓慢进入，然后加速离开</td>
</tr>
<tr>
<td style="text-align:center">kCAMediaTimingFunctionEaseOut（渐出）</td>
<td style="text-align:center">动画全速进入，然后减速的到达目的地</td>
</tr>
<tr>
<td style="text-align:center">kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）</td>
<td style="text-align:center">匀速,相对静态的感觉</td>
</tr>
<tr>
<td style="text-align:center">kCAMediaTimingFunctionLinear（线性）</td>
<td style="text-align:center">动画缓慢的进入，中间加速，然后减速的到达目的地。默认的动画行为</td>
</tr>
</tbody>
</table>
<h5 id="动画代理"><a href="#动画代理" class="headerlink" title="动画代理"></a>动画代理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (CAAnimationDelegate)</div><div class="line"> - (void)animationDidStart:(CAAnimation *)anim;</div><div class="line"> - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>检测动画的执行和结束</p>
<h4 id="动画的使用"><a href="#动画的使用" class="headerlink" title="动画的使用"></a>动画的使用</h4><h5 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h5><p>CABasicAnimation可以看作一种特殊的关键帧动画,只有头尾两个关键帧</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">fromValue</td>
<td style="text-align:center">开始值</td>
</tr>
<tr>
<td style="text-align:center">toValue</td>
<td style="text-align:center">结束值</td>
</tr>
<tr>
<td style="text-align:center">byValue</td>
<td style="text-align:center">keyPath属性的变化值(使用较少)</td>
</tr>
</tbody>
</table>
<p>动画执行过程说明：</p>
<blockquote>
<p>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue</p>
</blockquote>
<p>可以改变的值(<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2" target="_blank" rel="external">详细查看</a>):</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/CoreAnimateKeyPath.png" alt="KeyPath description"></p>
<p>基础动画主要提供了对于CALayer对象中的可变属性进行简单动画的操作。比如：位移、透明度、缩放、旋转、背景色等等。</p>
<h6 id="移动动画"><a href="#移动动画" class="headerlink" title="移动动画"></a>移动动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    animation.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, 120)];</div><div class="line">    animation.toValue   = [NSValue valueWithCGPoint:CGPointMake(K_width, K_height/2+85)];</div><div class="line">    animation.duration = 2.0f;</div><div class="line">    animation.autoreverses = YES;</div><div class="line">    </div><div class="line">    // 动画执行完毕后，图层会保持显示动画执行后的状态</div><div class="line">//    animation.removedOnCompletion = NO;</div><div class="line">//    animation.fillMode = kCAFillModeForwards;</div><div class="line">  </div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];</div><div class="line">    [self.rectView.layer addAnimation:animation forKey:@&quot;moveViewLayer&quot;];</div></pre></td></tr></table></figure>
<h6 id="缩放动画"><a href="#缩放动画" class="headerlink" title="缩放动画"></a>缩放动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *animate = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class="line">animate.duration = 2.5f;</div><div class="line">animate.toValue = [NSNumber numberWithFloat:2.0];</div><div class="line">[self.rectView.layer addAnimation:animate forKey:@&quot;animateScale&quot;];</div></pre></td></tr></table></figure>
<h6 id="旋转动画"><a href="#旋转动画" class="headerlink" title="旋转动画"></a>旋转动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">animation.duration = 2.5f;</div><div class="line">animation.fromValue = [NSNumber numberWithFloat:0.0f];</div><div class="line">animation.toValue = [NSNumber numberWithFloat:M_PI];</div><div class="line">[self.rectView.layer addAnimation:animation forKey:@&quot;rotateLayer&quot;];</div></pre></td></tr></table></figure>
<h6 id="组合动画"><a href="#组合动画" class="headerlink" title="组合动画"></a>组合动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 动画1（在X轴方向移动）</div><div class="line">CABasicAnimation *animation1 =</div><div class="line">[CABasicAnimation animationWithKeyPath:@&quot;transform.translation.x&quot;];</div><div class="line">// 终点设定</div><div class="line">animation1.toValue = [NSNumber numberWithFloat:80];;</div><div class="line"></div><div class="line">// 动画2（绕Z轴中心旋转</div><div class="line">CABasicAnimation *animation2 =</div><div class="line">[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">// 设定旋转角度</div><div class="line">animation2.fromValue = [NSNumber numberWithFloat:0.0];</div><div class="line">animation2.toValue = [NSNumber numberWithFloat:2 * M_PI];</div><div class="line"></div><div class="line">//动画2</div><div class="line">CABasicAnimation *animation3 =</div><div class="line">[CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class="line">animation3.toValue = [NSNumber numberWithFloat:1.5f];</div><div class="line"></div><div class="line">// 动画组</div><div class="line">CAAnimationGroup *group = [CAAnimationGroup animation];</div><div class="line"></div><div class="line">// 动画选项设定</div><div class="line">group.duration = 3.0;</div><div class="line">group.repeatCount = 1;</div><div class="line">group.autoreverses = YES;</div><div class="line"></div><div class="line">// 添加动画</div><div class="line">group.animations = [NSArray arrayWithObjects:animation1, animation2,animation3, nil];</div><div class="line">[self.rectView.layer addAnimation:group forKey:@&quot;Comlayer&quot;];</div></pre></td></tr></table></figure>
<p>注意点：如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变</p>
<h5 id="CAKeyframeAnimation"><a href="#CAKeyframeAnimation" class="headerlink" title="CAKeyframeAnimation"></a>CAKeyframeAnimation</h5><p>CAKeyframeAnimation和CABaseAnimation都属于CAPropertyAnimatin的子类。CABaseAnimation只能从一个数值（fromValue）变换成另一个数值（toValue）,而CAKeyframeAnimation则会使用一个NSArray保存一组关键帧。</p>
<p>属性说明：</p>
<blockquote>
<ul>
<li>values：NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</li>
<li>path ：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果设置了path，那么values将被忽略<br>可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</li>
</ul>
</blockquote>
<h6 id="calculationMode"><a href="#calculationMode" class="headerlink" title="calculationMode"></a>calculationMode</h6><p>在关键帧动画中有一个非常重要的参数,那便是calculationMode,计算模式.其主要针对的是每一帧的内容为一个座标点的情况,也就是对anchorPoint 和 position 进行的动画.当在平面座标系中有多个离散的点的时候,可以是离散的,也可以直线相连后进行插值计算,也可以使用圆滑的曲线将他们相连后进行插值计算.calculationMode目前提供如下几种模式:</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kCAAnimationLinear</td>
<td style="text-align:center">Default,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算</td>
</tr>
<tr>
<td style="text-align:center">kCAAnimationDiscrete</td>
<td style="text-align:center">离散的,就是不进行插值计算,所有关键帧直接逐个进行显示</td>
</tr>
<tr>
<td style="text-align:center">kCAAnimationPaced</td>
<td style="text-align:center">使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions无效</td>
</tr>
<tr>
<td style="text-align:center">kCAAnimationCubic</td>
<td style="text-align:center">对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算,对于曲线的形状还可以通过tensionValues,continuityValues,biasValues来进行调整自定义,这里的数学原理是Kochanek–Bartels spline,这里的主要目的是使得运行的轨迹变得圆滑</td>
</tr>
<tr>
<td style="text-align:center">kCAAnimationCubicPaced</td>
<td style="text-align:center">看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的</td>
</tr>
</tbody>
</table>
<h6 id="基于贝赛尔曲线路径的关键帧动画"><a href="#基于贝赛尔曲线路径的关键帧动画" class="headerlink" title="基于贝赛尔曲线路径的关键帧动画"></a>基于贝赛尔曲线路径的关键帧动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CAKeyframeAnimation *keyAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(K_width/2 - 100, K_height/2 - 100, 200, 200)];</div><div class="line">keyAnimation.duration = 2.0f;</div><div class="line">keyAnimation.path = path.CGPath;</div><div class="line">keyAnimation.delegate = self;</div><div class="line">[_rectView.layer addAnimation:keyAnimation forKey:@&quot;pathAnimation&quot;];</div></pre></td></tr></table></figure>
<h6 id="基于位置点的关键桢动画"><a href="#基于位置点的关键桢动画" class="headerlink" title="基于位置点的关键桢动画"></a>基于位置点的关键桢动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">CAKeyframeAnimation *rotAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform&quot;];</div><div class="line">CATransform3D rotation1 = CATransform3DMakeRotation(30 * M_PI/180, 0, 0, -1);</div><div class="line">CATransform3D rotation2 = CATransform3DMakeRotation(60 * M_PI/180, 0, 0, -1);</div><div class="line">CATransform3D rotation3 = CATransform3DMakeRotation(90 * M_PI/180, 0, 0, -1);</div><div class="line">CATransform3D rotation4 = CATransform3DMakeRotation(120 * M_PI/180, 0, 0, -1);</div><div class="line">CATransform3D rotation5 = CATransform3DMakeRotation(150 * M_PI/180, 0, 0, -1);</div><div class="line">CATransform3D rotation6 = CATransform3DMakeRotation(180 * M_PI/180, 0, 0, -1);</div><div class="line"></div><div class="line">[rotAnimation setValues:[NSArray arrayWithObjects:</div><div class="line">                    [NSValue valueWithCATransform3D:rotation1],</div><div class="line">                    [NSValue valueWithCATransform3D:rotation2],</div><div class="line">                    [NSValue valueWithCATransform3D:rotation3],</div><div class="line">                    [NSValue valueWithCATransform3D:rotation4],</div><div class="line">                    [NSValue valueWithCATransform3D:rotation5],</div><div class="line">                    [NSValue valueWithCATransform3D:rotation6],</div><div class="line">                    nil]];</div><div class="line">[rotAnimation setKeyTimes:[NSArray arrayWithObjects:</div><div class="line">                      [NSNumber numberWithFloat:0.0],</div><div class="line">                      [NSNumber numberWithFloat:0.2f],</div><div class="line">                      [NSNumber numberWithFloat:0.4f],</div><div class="line">                      [NSNumber numberWithFloat:0.6f],</div><div class="line">                      [NSNumber numberWithFloat:0.8f],</div><div class="line">                      [NSNumber numberWithFloat:1.0f],</div><div class="line">                      nil]];</div><div class="line">rotAnimation.duration = 4.0f;</div><div class="line">rotAnimation.fillMode = kCAFillModeForwards;</div><div class="line">[rotAnimation setRemovedOnCompletion:NO];</div><div class="line">[_rectView.layer addAnimation:rotAnimation forKey:nil];</div></pre></td></tr></table></figure>
<h5 id="CAGroupAnimation"><a href="#CAGroupAnimation" class="headerlink" title="CAGroupAnimation"></a>CAGroupAnimation</h5><p>CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。需要注意的是Group中设置的属性优先级高于内部每一个动画的属性，比如内部Animation.removedOnCompletion = YES;,但是在group中设置了GroupAnimation.removedOnCompletion = NO;GroupAnimation.fillMode = kCAFillModeForwards;内部属性即为无效</p>
<h6 id="组合Group动画"><a href="#组合Group动画" class="headerlink" title="组合Group动画"></a>组合Group动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">CAKeyframeAnimation *keyAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, K_height/2 - 60)];</div><div class="line">NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(K_width/3, K_height/2 - 60)];</div><div class="line">NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(K_width, K_height/2 + 60)];</div><div class="line">NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(K_width/2*3, K_height/2 + 60)];</div><div class="line">NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(K_width/2*3, K_height/2 - 60)];</div><div class="line">NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(K_width, K_height/2 - 60)];</div><div class="line">keyAnimation.values = @[value0,value1,value2,value3,value4,value5];</div><div class="line"></div><div class="line">CABasicAnimation *scaleAni = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class="line">scaleAni.fromValue = [NSNumber numberWithFloat:0.8f];</div><div class="line">scaleAni.toValue   = [NSNumber numberWithFloat:2.f];</div><div class="line"></div><div class="line">CABasicAnimation *rotAni = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation&quot;];</div><div class="line">rotAni.toValue = [NSNumber numberWithFloat:M_PI * 4];</div><div class="line"></div><div class="line">CAAnimationGroup *groupAnimation = [CAAnimationGroup animation];</div><div class="line">groupAnimation.animations = @[keyAnimation,scaleAni,rotAni];</div><div class="line">groupAnimation.duration = 4.f;</div><div class="line"></div><div class="line">[_rectView.layer addAnimation:groupAnimation forKey:@&quot;groupAnimation&quot;];</div></pre></td></tr></table></figure>
<h5 id="CATransition"><a href="#CATransition" class="headerlink" title="CATransition"></a>CATransition</h5><p>CAAnimation的子类，一般用于过渡动画或者转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">startProgress</td>
<td style="text-align:center">动画开始(在整体动画的百分比)</td>
</tr>
<tr>
<td style="text-align:center">endProgress</td>
<td style="text-align:center">动画停止(在整体动画的百分比)</td>
</tr>
</tbody>
</table>
<p><strong>重要属性</strong><br>动画过渡类型(Type)，Apple 官方的只提供了四种过渡效果:</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kCATransitionFade</td>
<td style="text-align:center">渐变效果（淡出）</td>
</tr>
<tr>
<td style="text-align:center">kCATransitionMoveIn</td>
<td style="text-align:center">新视图移到旧视图上面</td>
</tr>
<tr>
<td style="text-align:center">kCATransitionPush</td>
<td style="text-align:center">新视图把旧视图推出去</td>
</tr>
<tr>
<td style="text-align:center">kCATransitionReveal</td>
<td style="text-align:center">将旧视图移开,显示下面的新视图</td>
</tr>
<tr>
<td style="text-align:center"><strong><em>私有API</em></strong></td>
<td style="text-align:center"><strong><em>属性说明（私有）</em></strong></td>
</tr>
<tr>
<td style="text-align:center">cube</td>
<td style="text-align:center">立方体翻滚效果</td>
</tr>
<tr>
<td style="text-align:center">oglFlip</td>
<td style="text-align:center">上下左右翻转效果</td>
</tr>
<tr>
<td style="text-align:center">suckEffect</td>
<td style="text-align:center">收缩效果,纸张被抽走</td>
</tr>
<tr>
<td style="text-align:center">rippleEffect</td>
<td style="text-align:center">水滴效果</td>
</tr>
<tr>
<td style="text-align:center">pageCurl</td>
<td style="text-align:center">向上翻页效果</td>
</tr>
<tr>
<td style="text-align:center">pageUnCurl</td>
<td style="text-align:center">向下翻页效果</td>
</tr>
<tr>
<td style="text-align:center">cameraIrisHollowOpen</td>
<td style="text-align:center">相机镜头打开效果</td>
</tr>
<tr>
<td style="text-align:center">cameraIrisHollowClos</td>
<td style="text-align:center">相机镜头关闭效果</td>
</tr>
</tbody>
</table>
<p>上图中<strong>前四个为公开的API</strong>，后面一部分为私有API。私有的API可能会导致app审核不通过，慎用。</p>
<p>动画过渡方向(subtype)：</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">kCATransitionFromRight</td>
<td style="text-align:center">从右侧进入</td>
</tr>
<tr>
<td style="text-align:center">kCATransitionFromLeft</td>
<td style="text-align:center">从左侧进入</td>
</tr>
<tr>
<td style="text-align:center">kCATransitionFromTop</td>
<td style="text-align:center">从顶部进入</td>
</tr>
<tr>
<td style="text-align:center">kCATransitionFromBottom</td>
<td style="text-align:center">从底部进入</td>
</tr>
</tbody>
</table>
<h6 id="基于CATransition的过渡动画"><a href="#基于CATransition的过渡动画" class="headerlink" title="基于CATransition的过渡动画"></a>基于CATransition的过渡动画</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CATransition *anima = [CATransition animation];</div><div class="line">anima.type = kCATransitionFade;// 动画过渡的类型</div><div class="line">anima.subtype = kCATransitionFromRight; // 动画过渡方向</div><div class="line">anima.duration = 1.0f;</div><div class="line">[_rectView.layer addAnimation:anima forKey:@&quot;fadeAnimation&quot;];</div></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>任何复杂的动画其实都是由一个个简单的动画组装而成的，要善于分解和组装。好的动画需要一步步调整。</p>
<p><a href="https://github.com/chaosyuan/CoreAnimations" target="_blank" rel="external">demo下载地址</a></p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514" target="_blank" rel="external">Core Animation Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Animation_Types_Timing/Articles/PropertyAnimations.html" target="_blank" rel="external">iOS官方文档demo</a></li>
<li><a href="http://geeklu.com/2012/09/animation-in-ios/" target="_blank" rel="external">谈谈iOS Animation</a></li>
<li><a href="http://www.cnblogs.com/xdream86/p/3250782.html" target="_blank" rel="external">Core Animation编程指南</a>  </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Core Animation是iOS与mac OS 平台上负责图形渲染与动画的基础框架。Core Animation可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘帧工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用Core Animation的动画效果。Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，而且不会加重CPU的负担而影响程序的运行速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
      <category term="动画" scheme="http://chaosyuan.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>ReactiveCocoa学习之路（一）</title>
    <link href="http://chaosyuan.github.io/2016/03/02/2016-03-02-reactivecocoaxue-xi-zhi-lu1/"/>
    <id>http://chaosyuan.github.io/2016/03/02/2016-03-02-reactivecocoaxue-xi-zhi-lu1/</id>
    <published>2016-03-02T06:31:22.000Z</published>
    <updated>2016-08-19T02:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><a href="https://www.github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="external">ReactiveCocoa</a>（简称RAC）是最初由GitHub团队开发的一套基于Cocoa的FRP框架。FRP即Functional Reactive Programming（函数式响应编程）。ReactiveCocoa结合了几种编程风格：</p>
<blockquote>
<p>函数式编程（<a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">Functional Programming</a>）：使用高阶函数，例如函数用其他函数作为参数<br>响应式编程（<a href="http://en.wikipedia.org/wiki/Reactive_programming" target="_blank" rel="external">Reactive Programming</a>）：关注于数据流和变化传播</p>
</blockquote>
<a id="more"></a>
<p>在iOS开发中,不同的响应事件采用不同的方式来处理，比如action、delegate、KVO、callback等，并没有一个统一的处理方式。而ReactiveCocoa为事件定义了一个标准接口，提供统一的消息传递机制，并且减少可变变量的定义。RAC提供Signals捕获当前值和将来值。通过链接（chaining），组合（combining）和对Signals做出反应（reacting）。我们不必频繁地观察并更新值，而是声明式编写软件。</p>
<p>总的来说： RAC统一了对KVO、UI Event、Network request、Async work的处理，因为它们本质上都是值的变化(Values over time)</p>
<h4 id="RACStream"><a href="#RACStream" class="headerlink" title="RACStream"></a>RACStream</h4><p>ReactiveCocoa的核心组件是RACStream，RACStream作为一个描述的抽象类，是任意对象的值的一个序列( any series of object values )，stream表示流，流驱动事件，一个流驱动响应另一个流，所有的流连串起来，形成事件流，类似于流驱动事件，RACStream的两个子类分别是<strong>RACSignal</strong>和<strong>RACSequence</strong></p>
<h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p>signal即信号，信号也是一种流，信号需要订阅，如同报纸一样，只有你订阅了，才会把报纸送到订阅者那里，没有订阅就没有实际意义。专业术语称：Hot Observable（热信号）和Cold Observable（冷信号），两者的区别是：</p>
<blockquote>
<ol>
<li>Hot Observable是主动的，尽管你并没有订阅事件，但是它会时刻推送，就像鼠标移动；而Cold Observable是被动的，只有当你订阅的时候，它才会发布消息。</li>
<li>Hot Observable可以有多个订阅者，是一对多，集合可以与订阅者共享信息；而Cold Observable只能一对一，当有不同的订阅者，消息是重新完整发送</li>
</ol>
</blockquote>
<p>总的来说：有subscriber(订阅者)的signal为热信号，没有subscriber的signal为冷信号</p>
<p>RACSignal可以向订阅者subscriber发送三种不同类型的事件：</p>
<blockquote>
<ul>
<li>next:这个主要起到传值的作用，这个值可以为nil；</li>
<li>error:发送一个NSError对象,通知订阅者信号发送了错误</li>
<li>completed:表明信号已经结束，并且不会有新的值传递给订阅者；</li>
</ul>
</blockquote>
<p>一个生命周期的Signal可以发送任意多个“next”事件，和一个“error”或者“completed”事件（“error”和“completed”只可能出现一种）</p>
<p>对于RACSignal来说，最核心的方法即：-subscribe:。通过查看RACSignal源码可以发现，这个是一个抽象方法，需要其子类去实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber &#123;</div><div class="line">	NSCAssert(NO, @&quot;This method must be overridden by subclasses&quot;);</div><div class="line">	return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>RACSignal的子类有：</p>
<blockquote>
<ul>
<li>RACEmptySignal：空信号，用来实现 RACSignal 的 +empty 方法；</li>
<li>RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法；</li>
<li>RACSubject：既可以充当信号，又能发送信号（过于灵活，滥用的话容易导致复杂度的增加。但有一些场景还是比较方便的）；</li>
<li>RACDynamicSignal ：动态信号，使用一个 block 来实现订阅行为，在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；</li>
<li>RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法；<br>RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定；</li>
</ul>
</blockquote>
<p>所有的子类都实现了-subscribe:方法。不同子类实现也不同，用来区分不同子类的功能</p>
<h4 id="RACSubscriber"><a href="#RACSubscriber" class="headerlink" title="RACSubscriber"></a>RACSubscriber</h4><p>ReactiveCocoa综合了Delegate,Notification,Block,KVO等对于RAC来说。主要是信号和订阅者机制，例如点击一个按钮，产生一个signal，然后被Subscriber订阅后，可以响应相应的事件。<a href="http://limboy.me/" target="_blank" rel="external">limboy</a> 有个很形象的比喻就是每个signal好比一个插头，Subscriber好比插座，插头可以插在任意的插座上，也就是signal可以被多个Subscriber订阅，但是只有订阅后，才会响应。RACSubscriber是一种<strong>协议</strong>，而实现了这种协议的任何类都可以作为信号源的订阅者</p>
<p>查看RACSubscriber源码，RACSubscriber协议中定义了4个required方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol RACSubscriber &lt;NSObject&gt;</div><div class="line">@required</div><div class="line">- (void)sendNext:(id)value;</div><div class="line">- (void)sendError:(NSError *)error;</div><div class="line">- (void)sendCompleted;</div><div class="line">- (void)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>主要说一下-didSubscribeWithDisposable: 方法，用来接收代表某次订阅的 disposable 对象，一个订阅者可以订阅多个信号源，所以一个订阅者可以receive多个disposable对象。</p>
<p>在ReactiveCocoa中，有4个类实现了RACSubscriber协议：</p>
<blockquote>
<ol>
<li>RACSubject;</li>
<li>RACChannerl</li>
<li>RACPassthroughSubscriber</li>
<li>RACSubscriber+Private</li>
</ol>
</blockquote>
<p>其中RACSubject和RACChannerl是RACSignal的子类。RACSubscriber+Private是与RACSubscriber协议同名的实现类，一般RACSubscriber是信号源的真正订阅者。</p>
<p>RACPassthroughSubscriber（订阅者装饰器），订阅者每一次订阅信号是产生一个 Disposable ，并将其与此次订阅关联起来，通过装饰器 RACPassthroughSubscriber 来做到，装饰器的功能如下：</p>
<blockquote>
<p>包装真正的订阅者，使自己成为订阅者的替代者<br>将真正的订阅者与一个订阅时产生的 Disposable 关联起来</p>
</blockquote>
<p>订阅者装饰器是为了实现可以随时取消众多订阅中的任何一个功能。并且在它的内部封装了一个RACSubscriber对象，它负责将事件转发给这个订阅者，并且在转发之前，判断此次订阅是否被取消.</p>
<p>RACDynamicSignal 使用 RACPassthroughSubscriber ,订阅者装饰器直接伪装成真正的订阅器，传给 didSubscribe 这个 block 使用。在这个 block 中，会有一些事件发送给订阅者装饰器，而这个订阅者装饰器则根据 disposable 的状态来来决定是否转发给真正的订阅者。disposable 作为返回值，返回给外部，也就是说能够从外部来取消这个订阅了.关于这一点后面会详细说明。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>    [self.textfield.rac_textSignal subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>在textfield中输入任何内容，都会实时打印在控制台上（这个类似于AngularJS的双向绑定机制）。ReactiveCocoa框架使用category来为很多基本的UIKit控件添加signal。以便能够很简单的给控件添加订阅。来看一下rac_textSignal源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)rac_textSignal &#123;</div><div class="line">	@weakify(self);</div><div class="line">	return [[[[[RACSignal</div><div class="line">        // 能够将冷信号转化为热信号</div><div class="line">		defer:^&#123;</div><div class="line">			@strongify(self);</div><div class="line">			return [RACSignal return:self];</div><div class="line">		&#125;]</div><div class="line">        // 根据UIControlEventEditingChanged事件生成一个新信号，衔接新旧信号，旧信号执行完执行新信号</div><div class="line">		concat:[self rac_signalForControlEvents:UIControlEventAllEditingEvents]]</div><div class="line">              </div><div class="line">        // 对UITextField进行映射解析，返回UITextField的text值</div><div class="line">		map:^(UITextField *x) &#123;</div><div class="line">			return x.text;</div><div class="line">		&#125;]</div><div class="line">     </div><div class="line">        // 当rac_willDeallocSignal执行next或completed时，返回信号执行completed</div><div class="line">        // takeUntil 获取信号直到某个信号执行完成</div><div class="line">		takeUntil:self.rac_willDeallocSignal]</div><div class="line">        // 给signal起别名，方便debug调试</div><div class="line">		setNameWithFormat:@&quot;%@ -rac_textSignal&quot;, self.rac_description];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以上面的代码也可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[[self.textfield rac_signalForControlEvents:UIControlEventEditingChanged] subscribeNext:^(UITextField *x) &#123;</div><div class="line">         NSLog(@&quot;%@&quot;,x.text);</div><div class="line">     &#125;];</div></pre></td></tr></table></figure></p>
<p>再看一下rac_signalForControlEvents的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)rac_signalForControlEvents:(UIControlEvents)controlEvents &#123;</div><div class="line">	@weakify(self);</div><div class="line"></div><div class="line">	return [[RACSignal</div><div class="line">		createSignal:^(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line">			@strongify(self);</div><div class="line"></div><div class="line">			[self addTarget:subscriber action:@selector(sendNext:) forControlEvents:controlEvents];</div><div class="line">			[self.rac_deallocDisposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</div><div class="line">				[subscriber sendCompleted];</div><div class="line">			&#125;]];</div><div class="line"></div><div class="line">			return [RACDisposable disposableWithBlock:^&#123;</div><div class="line">				@strongify(self);</div><div class="line">				[self removeTarget:subscriber action:@selector(sendNext:) forControlEvents:controlEvents];</div><div class="line">			&#125;];</div><div class="line">		&#125;]</div><div class="line">		setNameWithFormat:@&quot;%@ -rac_signalForControlEvents: %lx&quot;, self.rac_description, (unsigned long)controlEvents];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是UIControl的分类。在方法内部采用了target-action的方法进行事件传递，其中target是RACSubscriber的实例，并且action是RACSubscriber中订阅的协议方法- (void)sendNext:(id)value，最终调用的即是subscribeNext:^(id x)的block。最后信号在removeTarget的时候被销毁。</p>
<blockquote>
<p>1.创建信号，并将textfield的事件通过target-action的方式转移到信号的订阅者上。<br>2.创建订阅者，并将subscribeNext中的block拷贝到订阅者内部。<br>3.当触发textfield的controlEvents时，通过拷贝的block，将事件传递给外部block，并对信号传递的值进行映射。<br>4.当rac_willDeallocSignal执行next或者completed时结束</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ReactiveCocoa虽然很难入门，但是的确强大，希望自己能够在后面的持续学习中，能够慢慢理解和运用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://www.github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;ReactiveCocoa&lt;/a&gt;（简称RAC）是最初由GitHub团队开发的一套基于Cocoa的FRP框架。FRP即Functional Reactive Programming（函数式响应编程）。ReactiveCocoa结合了几种编程风格：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数式编程（&lt;a href=&quot;http://en.wikipedia.org/wiki/Functional_programming&quot;&gt;Functional Programming&lt;/a&gt;）：使用高阶函数，例如函数用其他函数作为参数&lt;br&gt;响应式编程（&lt;a href=&quot;http://en.wikipedia.org/wiki/Reactive_programming&quot;&gt;Reactive Programming&lt;/a&gt;）：关注于数据流和变化传播&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
      <category term="ReactiveCocoa" scheme="http://chaosyuan.github.io/tags/ReactiveCocoa/"/>
    
  </entry>
  
  <entry>
    <title>block 实现原理及内存管理</title>
    <link href="http://chaosyuan.github.io/2016/02/25/2016-02-25-block-nei-cun-guan-li/"/>
    <id>http://chaosyuan.github.io/2016/02/25/2016-02-25-block-nei-cun-guan-li/</id>
    <published>2016-02-25T11:11:14.000Z</published>
    <updated>2016-08-26T09:40:37.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观。使用起来十分的方便。同时也是iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，才能从根本上避免挖坑和踩坑。</p>
<p>block 只是 Objective-C 对<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">闭包</a>的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同</p>
<a id="more"></a>
<h4 id="block-结构体详解"><a href="#block-结构体详解" class="headerlink" title="block 结构体详解"></a>block 结构体详解</h4><p>将下面的 <strong>hello.m</strong> 用 clang 编译成 <strong>hello.cpp</strong> </p>
<p><strong>test.m</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/************* Objective-C 源码 *************/</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    void (^block)() = ^&#123;</div><div class="line">        NSLog(@&quot;hello world&quot;);</div><div class="line">    &#125;;</div><div class="line">    block();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>test.cpp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/************* 使用 clang 编译后（部分）如下 *************/</div><div class="line"></div><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__1_wj5fwdw95j99yz601c6h_ttm0000gn_T_hello_35d731_mi_0);</div><div class="line">    &#125;</div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main() &#123;</div><div class="line">    void (*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="struct-block-impl"><a href="#struct-block-impl" class="headerlink" title="struct __block_impl"></a>struct __block_impl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>isa：指向对象所属的类，表明 block 本身也是一个 OC 对象。block按照内存位置，可分为三种类型：</p>
<blockquote>
<p>NSConcreteStackBlock  全局区block<br>NSConcreteGlobalBlock  栈区block<br>NSConcreteMallocBlock 堆区Block</p>
</blockquote>
</li>
<li><p>Flags：按bit位表示一些block的附加信息，比如判断block类型、判断block引用计数、判断block是否需要执行辅助函数等</p>
</li>
<li>Reserved ：保留变量</li>
<li>FuncPtr ：函数指针，指向 Block 要执行的函数（入口地址）</li>
</ul>
<h5 id="struct-main-block-impl-0"><a href="#struct-main-block-impl-0" class="headerlink" title="struct __main_block_impl_0"></a>struct __main_block_impl_0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>impl：block实现的结构体变量，该结构体上面已说明</li>
<li>Desc：描述 block 的结构体变量</li>
<li>__main_block_impl_0：结构体的构造函数。初始化 impl、Desc</li>
</ul>
<h5 id="static-void-main-block-func-0"><a href="#static-void-main-block-func-0" class="headerlink" title="static void __main_block_func_0"></a>static void __main_block_func_0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// void __main_block_func_0 是 block 最终要执行的函数</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__1_wj5fwdw95j99yz601c6h_ttm0000gn_T_hello_35d731_mi_0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="static-struct-main-block-desc-0"><a href="#static-struct-main-block-desc-0" class="headerlink" title="static struct __main_block_desc_0"></a>static struct __main_block_desc_0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// struct __main_block_desc_0 是对 block 进行描述的结构体</div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>reserved ：结构体信息保留字段</li>
<li>Block_size ：结构体大小<br>此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA</li>
</ul>
<h5 id="最基础的-block-执行流程"><a href="#最基础的-block-执行流程" class="headerlink" title="最基础的 block 执行流程"></a>最基础的 block 执行流程</h5><p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/nomalBlock.png" alt="最基础的 block 执行流程"></p>
<h4 id="block-获取外部变量"><a href="#block-获取外部变量" class="headerlink" title="block 获取外部变量"></a>block 获取外部变量</h4><p>运行如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">  int a = 10;</div><div class="line">  void (^block)() = ^&#123;</div><div class="line">    printf(&quot;a = %d\n&quot;, a);</div><div class="line">  &#125;;</div><div class="line">   block();</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = 10</div></pre></td></tr></table></figure></p>
<p>和第一段源码不同的是，这里多局部变量 a，而且还在 block 里面获取到了。前面源码分析中，了解到 block 的函数定义在 main() 函数之外。那又是如何获取 main() 里面的局部变量呢? 为了弄明白，再次用 clang 重写这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int a;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int a = __cself-&gt;a; // bound by copy</div><div class="line"></div><div class="line">    printf(&quot;a = %d\n&quot;, a);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main()&#123;</div><div class="line">  int a = 10;</div><div class="line">  void (*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</div><div class="line">   ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来 block 通过参数值传递，获取到变量a ，通过函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a)</div></pre></td></tr></table></figure>
<p>保存到 <strong>main_block_impl_0 结构体的同名变量 a，通过代码 int a = </strong>cself-&gt;a; 取出 a，打印出来.</p>
<p>构造函数 __main_block_impl_0 冒号后的表达式 a(_a) 的意思是，用 _a初始化结构体成员变量 a</p>
<p>这里能获取到外部变量主要是：值传递</p>
<p>如果在 block 内部修改 a 的值，会报编译错误</p>
<h4 id="block-修改外部变量"><a href="#block-修改外部变量" class="headerlink" title="block 修改外部变量"></a>block 修改外部变量</h4><p>从上面的demo代码中，可以知道在block中可以读取外部的局部变量，但是没有写操作权限，也就是写操作无效。在 C 语言中有三种类型的变量，可在 block 内进行读写操作</p>
<blockquote>
<p>全局变量<br>全局静态变量<br>静态变量</p>
</blockquote>
<p>全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别,而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang ，可以发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上面的demo中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当需要修改外部变量时，是不是也可以像 静态变量 这样通过指针传递来修改外部变量的值呢？在OC中有个修饰符__block可以做到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/************* 使用 __block 修饰 *************/</div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">        __block int b = 10;</div><div class="line">        void (^block)() = ^&#123;</div><div class="line">            printf(&quot;%d\n&quot;,b);</div><div class="line">        &#125;;</div><div class="line">        b  = 20;</div><div class="line">        block();</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/************* 使用 clang 编译后（部分）如下 *************/</div><div class="line">// 存储 __block 外部变量的结构体</div><div class="line">struct __Block_byref_b_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_b_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_b_0 *b; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_b_0 *_b, int flags=0) : b(_b-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_b_0 *b = __cself-&gt;b; // bound by ref</div><div class="line"></div><div class="line">            printf(&quot;%d\n&quot;,(b-&gt;__forwarding-&gt;b));</div><div class="line">        &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;b, (void*)src-&gt;b, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;b, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_b_0 b = &#123;(void*)0,(__Block_byref_b_0 *)&amp;b, 0, sizeof(__Block_byref_b_0), 10&#125;;</div><div class="line">        void (*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_b_0 *)&amp;b, 570425344));</div><div class="line">        (b.__forwarding-&gt;b) = 20;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里代码量比之前增加了一些</p>
<blockquote>
<p> <strong>_struct __Block_byref_b_0</strong> 结构体：用于封装 __block 修饰的外部变量<br> <strong>_Block_object_assign</strong> 函数：当block从栈拷贝到堆时，调用此函数<br> <strong>_Block_object_dispose</strong> 函数：当 block 从堆内存释放时，调用此函数</p>
</blockquote>
<p>从代码中可以看出 <strong>__block b</strong> 翻译后变成了 <strong>__Block_byref_b_0</strong>  结构体指针，通过指针传递到 block 内，这与前面说的 静态变量 的指针传递是一致的。也就是说对于用_block修饰的外部变量引用，block是复制其引用地址来实现访问的。除此之外，整体的执行流程与不加 <strong>block 基本一致。但 **</strong>Block_byref_b_0** 这个结构体需特别注意下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 存储 __block 外部变量的结构体</div><div class="line">struct __Block_byref_b_0 &#123;</div><div class="line">  void *__isa; // 对象指针</div><div class="line">__Block_byref_b_0 *__forwarding; // 指向自己的指针</div><div class="line"> int __flags; // 标志位变量</div><div class="line"> int __size; // 结构体大小</div><div class="line"> int b; // 外部变量</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于__forwarding这个指针，刚开始完全不知道它是干啥用的？在google后才知道它的用处，后面会详细介绍。</p>
<p>对于__block 修饰的变量，block的处理方法是copy其指针，在内部进行retain使其引用计数递增保证存活。</p>
<h4 id="block-内存分配"><a href="#block-内存分配" class="headerlink" title="block 内存分配"></a>block 内存分配</h4><p>上面说了block按照内存划分可以分为3种类型: <strong>NSGlobalBlock</strong> <strong>NSStackBlock</strong>,<strong>NSMallocBlock</strong></p>
<p>说到内存划分，先来看看由C/C++/OBJC编译的程序占用内存分布的结构<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/neiCunFenPei.png" alt="内存分布的结构-图片来自于程序员说的博客"></p>
<p>注：这里所说的堆和栈与数据结构中的堆和栈不是一回事</p>
<ul>
<li><p>栈区（stack）：由系统自动分配，一般存放函数参数值、局部变量的值等。由编译器自动创建与释放。其操作方式类似于数据结构中的栈，即后进先出、先进后出的原则</p>
<blockquote>
<p>例如：在函数中申明一个局部变量int a;系统自动在栈中为a开辟空间。</p>
</blockquote>
</li>
<li><p>堆区（heap）：一般由程序员申请并指明大小，最终也由程序员释放。如果程序员不释放，程序结束时可能会由OS回收。对于堆区的管理是采用链表式管理的，操作系统有一个记录空闲内存地址的链表，当接收到程序分配内存的申请时，操作系统就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后将该节点记录的内存地址分配给程序</p>
</li>
<li><p>全局区/静态区：全局变量和静态变量存储在这个区域。只不过初始化的全局变量和静态变量存储在一块，未初始化的全局变量和静态变量存储在一块。程序结束后由系统释放</p>
</li>
<li>文字常量区：这个区域主要存储字符串常量。程序结束后由系统释放</li>
<li>程序代码区：这个区域主要存放函数体的二进制代码</li>
</ul>
<h5 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h5><p>_NSConcreteGlobalBlock 类型的 block 处于内存的全局区，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多</p>
<blockquote>
<ol>
<li>当block写在全局作用域时，即为<strong>gloal block</strong></li>
<li>当 block 不获取任何外部变量时，即为 <strong>global block</strong></li>
</ol>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line"></div><div class="line">  ^&#123; printf(&quot;hello world\n&quot;);&#125;();</div><div class="line">  return  0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h5><p>保存在栈中的block，当函数返回时被销毁,例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int a = 10;</div><div class="line">    ^&#123; printf(&quot;%d\n&quot;,a); &#125; ();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于stack block 处在内存栈区，其变量作用域结束， block 就被废弃，为了解决这个问题，block 提供了copy功能，将block 和 __block 变量从栈拷贝到堆中，也就是MallocBlock</p>
<h5 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h5><p>当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以使用 block。那么此时，堆上的 block 类型为 _NSConcreteMallocBlock。例如，在exampleB_addBlockToArray方法中的block还是_NSConcreteStackBlock类型的，在exampleB方法中就被复制到了堆中，成为_NSConcreteMallocBlock类型的block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void exampleB_addBlockToArray(NSMutableArray *array) &#123;</div><div class="line">    int a = 10;</div><div class="line">    [array addObject:^&#123;</div><div class="line">            printf(&quot;%d\n&quot;, a);</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void exampleB() &#123;</div><div class="line">    NSMutableArray *array = [NSMutableArray array];</div><div class="line">    exampleB_addBlockToArray(array);</div><div class="line">    void (^block)() = [array objectAtIndex:0];</div><div class="line">    block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>__forwarding</strong></p>
<p>forwarding指针，这个指向自己的指针我疑惑了好久才明白，当 block 从栈被拷贝到堆时，__forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单。要从 __forwarding 产生的原因说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将   __forwarding 指针指向堆上结构体。后面如果要想使用 __block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*************** __forwarding 的作用 ***************/</div><div class="line">&#123;</div><div class="line">    __block int a = 0;</div><div class="line">    void (^blk)(void) = [^&#123;++a;&#125; copy];</div><div class="line">    ++a;</div><div class="line">    blk();</div><div class="line">    NSLog(@&quot;%d&quot;, a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印是 2。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 __forwarding 也会指向堆上的 __block 变量的结构体。</p>
<p>上面的代码中 ^{++a;} 和 ++a; 都会被转换成 ++(a.__forwarding-&gt;a);，堆上的 a 被加了两次，最后打印堆上的 a 为 2。</p>
<p>图解如下:</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/forwardingSelfHelp.png" alt="__forwarding point to heap"></p>
<h4 id="block-自动拷贝和手动拷贝"><a href="#block-自动拷贝和手动拷贝" class="headerlink" title="block 自动拷贝和手动拷贝"></a>block 自动拷贝和手动拷贝</h4><p>在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上。只有当：</p>
<blockquote>
<p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；</p>
</blockquote>
<p>剩下的这几种情况调用者就不需再手动拷贝:</p>
<blockquote>
<ul>
<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 拷贝</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/************ ARC下编译器自动拷贝block ************/</div><div class="line">typedef int (^blk)(int);</div><div class="line">blk func(int rate)</div><div class="line">&#123;</div><div class="line">    return ^(int count)&#123;return rate * count;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和预期结果不一样，ARC 到底给 block 做了什么？将上面的代码翻译下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">blk func(int rate)</div><div class="line">&#123;</div><div class="line">    blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);</div><div class="line">    tmp = objc_retainBlock(tmp);</div><div class="line">    return objc_autoreleaseReturnValue(tmp); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>换后出现两个新函数 objc_retainBlock、objc_autoreleaseReturnValue。关于runtime 库，具体<a href="http://opensource.apple.com/tarballs/objc4/objc4-493.9.tar.gz" target="_blank" rel="external">下载查看</a></p>
<p>由于 block 是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行</p>
<h4 id="ObjC对象的内存管理"><a href="#ObjC对象的内存管理" class="headerlink" title="ObjC对象的内存管理"></a>ObjC对象的内存管理</h4><p>说到block内存管理，出现问题最多的还是循环引用。objc对象，不同于基本类型，block会引起对象的引用计数变化。</p>
<p>代码如下（MRC环境）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">@interface chatModel : NSObject</div><div class="line">&#123;</div><div class="line">    NSObject *_instanceObj;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">@implementation chatModel</div><div class="line">NSObject* _globalObj = nil;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _instanceObj = [[NSObject alloc] init];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)test&#123;</div><div class="line">    static NSObject *_staticObj = nil;</div><div class="line">    _staticObj = [[NSObject alloc] init];</div><div class="line">    _globalObj = [[NSObject alloc] init];</div><div class="line">    </div><div class="line">    NSObject *localobj = [[NSObject alloc] init];</div><div class="line">    __block NSObject *blockObj = [[NSObject alloc] init];</div><div class="line">    </div><div class="line">    typedef void(^chatBlock)(void);</div><div class="line">    </div><div class="line">    chatBlock block = ^&#123;</div><div class="line">        NSLog(@&quot;%@&quot;,_globalObj);</div><div class="line">        NSLog(@&quot;%@&quot;,_staticObj);</div><div class="line">        NSLog(@&quot;%@&quot;,_instanceObj);</div><div class="line">        NSLog(@&quot;%@&quot;,localobj);</div><div class="line">        NSLog(@&quot;%@&quot;,blockObj);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    block = [[block copy] autorelease];</div><div class="line">    block();</div><div class="line">    </div><div class="line">    NSLog(@&quot;%ld&quot;, [_globalObj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [_staticObj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [_instanceObj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [localobj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [blockObj retainCount]);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        chatModel *chatObj = [[[chatModel alloc] init] autorelease];</div><div class="line">        [chatObj test];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果：1 1 1 2 1</p>
<blockquote>
<ul>
<li>_globalObj和_staticObj在内存中的全局区，位置是确定的，所以Block copy时不会retain对象</li>
<li>_instanceObj在Block copy时也没有直接retain _instanceObj对象本身，但会retain self。所以在Block中可以直接读写_instanceObj变量</li>
<li>localObj在Block copy时，系统自动retain对象，增加其引用计数</li>
<li>blockObj在Block copy时也不会retain</li>
</ul>
</blockquote>
<p>非ObjC对象，如GCD队列dispatch_queue_t。Block copy时并不会自动增加他的引用计数</p>
<p>注意：blockObj的<strong>block修饰符去除后，引用计数会加+1.说明没有 \</strong>block 修饰符的对象类型的变量则会被 retian.</p>
<p>在 MRC 下，使用 __block 修饰符也可以避免循环引用。因为当 block 从栈拷贝到堆时，__block 对象类型的变量不会被 retain，没有 __block 修饰符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，在写代码时一定要区分清楚到底是 ARC 还是 MRC.</p>
<blockquote>
<p>尽管 ARC 已经如此普及，可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存</p>
</blockquote>
<p>如下代码（ARC）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,copy)  void (^blk)();</div><div class="line"></div><div class="line">chatModel *obj = [[chatModel alloc] init];</div><div class="line">    self.blk = ^&#123;</div><div class="line">        NSLog(@&quot;%@&quot;,obj);</div><div class="line">    &#125;;</div><div class="line">  NSLog(@&quot;%@&quot;,[obj valueForKey:@&quot;retainCount&quot;]);</div></pre></td></tr></table></figure></p>
<p>打印结果：3<br>对象obj在Block被copy到堆上的时候自动retain了一次。因为Block不知道obj什么时候被释放，为了不在Block使用obj前被释放，Block retain了obj一次，在Block被释放的时候，obj被release一次</p>
<h5 id="retain-cycle"><a href="#retain-cycle" class="headerlink" title="retain cycle"></a>retain cycle</h5><p>retain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了闭环，谁也释放不了谁。</p>
<p>解决循环引用的关键在于：解除这个闭环，在实现开发工作中，一般处理的方式是使用弱引用 例如：<code>typeof(self) __weak weakSelf = self</code>或者手动将其中的一方置为nil。这个就不多说了</p>
<h5 id="提前释放"><a href="#提前释放" class="headerlink" title="提前释放"></a>提前释放</h5><p>如下面的例子，如果不只是request持有了Block，另一个对象也持有了Block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     +-----------+           +-----------+</div><div class="line">     | request   |           |   Block   |   objA</div><div class="line">----&gt;|           | --------&gt; |           |&lt;--------</div><div class="line">     | retain 1  | &lt; - - - - | retain 2  |</div><div class="line">     |           |   weak    |           |</div><div class="line">     +-----------+           +-----------+</div></pre></td></tr></table></figure>
<p>这时如果request 被持有者释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     +-----------+           +-----------+</div><div class="line">     | request   |           |   Block   |   objA</div><div class="line">--X-&gt;|           | --------&gt; |           |&lt;--------</div><div class="line">     | retain 0  | &lt; - - - - | retain 1  |</div><div class="line">     |           |   weak    |           |</div><div class="line">     +-----------+           +-----------+</div></pre></td></tr></table></figure>
<p>这时request已被完全释放，但Block仍被objA持有，没有释放，如果这时触发了Block，在Block中将访问已经销毁的request，这将导致程序crash。为了避免这种情况，所以开发时必须要注意对象和Block的生命周期</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是个人的实践和理解，如果有不正确的地方，欢迎批评指正。</p>
<h4 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h4><ol>
<li><a href="http://blog.csdn.net/jasonblog/article/details/7756763" target="_blank" rel="external">iOS中block实现的探究</a></li>
<li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></li>
<li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="external">正确使用Block避免Cycle Retain和Crash</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h4&gt;&lt;p&gt;block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观。使用起来十分的方便。同时也是iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，才能从根本上避免挖坑和踩坑。&lt;/p&gt;
&lt;p&gt;block 只是 Objective-C 对&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot;&gt;闭包&lt;/a&gt;的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
      <category term="block" scheme="http://chaosyuan.github.io/tags/block/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS 指令详解</title>
    <link href="http://chaosyuan.github.io/2016/02/16/2016-02-16-angularjs-zhi-ling-xiang-jie/"/>
    <id>http://chaosyuan.github.io/2016/02/16/2016-02-16-angularjs-zhi-ling-xiang-jie/</id>
    <published>2016-02-16T09:20:32.000Z</published>
    <updated>2016-08-19T02:02:20.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在公司的项目中用到AngularJs中的指令。所谓的指令在我理解看来。就是把浏览器能够识别的标签使用语法糖包装起来。在其它地方直接调用。这样极大方便了项目的开发和维护。在<a href="https://www.jucaifu.com/" target="_blank" rel="external">聚财富</a>项目中对通用的组件进行抽离，封装成自定义指令。整个工程都可以复用。在项目工程中创建语义化以及高度重用的组件，对于提高代码质量有很大的帮助，也方便扩展及后期维护。目前市场上的前端框架也只有AngularJS 拥有自定义指令的功能，并且AngularJS 是目前唯一提供Web应用可复用能力的框架。</p>
<a id="more"></a>
<h4 id="指令概述"><a href="#指令概述" class="headerlink" title="指令概述"></a>指令概述</h4><p>指令是DOM元素上的标记，使元素拥有特定的行为，也是用来扩展浏览器能力的技术之一。在DOM编译期间，和HTML元素关联着的指令会被检测到，并且被执行。这使得指令可以为DOM指定行为，或者改变它。AngularJS有一套完整的、可扩展的、用来帮助web应用开发的指令集（例如ng-repeat.ng-view.ng-controller等）。</p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p>下面说一下指令执行过程。</p>
<ol>
<li>浏览器得到 HTML 字符串内容，解析得成 DOM 结构</li>
<li>ng 引入，把 DOM 结构扔给 $compile 函数处理。</li>
</ol>
<blockquote>
<ol>
<li>找出 DOM 结构中有变量占位符</li>
<li>匹配找出 DOM 中包含的所有指令引用</li>
<li>把指令关联到 DOM节点上</li>
<li>DOM 中的多个指令按优先级排列</li>
<li>执行指令中的 compile 函数（改变 DOM 结构，返回 link 函数）</li>
</ol>
</blockquote>
<ol>
<li>执行 link 函数（连接模板的 $scope）<br>注意：$compile和compile，前者是ng内置服务，后者是指令中的编译函数。使用时注意区分。</li>
</ol>
<h4 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h4><p>指令的四种使用方式：</p>
<ol>
<li>作为元素(E) :<code>&lt;smsCode&gt;&lt;/smsCode&gt;</code></li>
<li>作为属性(A) :<code>&lt;div smsCode=&quot;sms&quot;&gt;&lt;/div&gt;</code></li>
<li>作为类名(C) :<code>&lt;div class=&quot;smsCode:sms;&quot;&gt;&lt;/div&gt;</code></li>
<li>作为注释(M) :<code>&lt;!-- directive: smsCode sms --&gt;</code></li>
</ol>
<p>在实际项目中常用的就是作为元素和属性。</p>
<h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><p>下面是一个标准指令的示例，可配置的参数包括以下部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  &apos;use strict&apos;;  </div><div class="line">angular.module(&apos;securityLoginToolbar&apos;)</div><div class="line">    .directive(&apos;loginToolbar&apos;, function factory(injectables) &#123;</div><div class="line"></div><div class="line">    var directiveDefinitionObject = &#123;</div><div class="line"></div><div class="line">        restrict: string,//指令的使用方式，包括元素，属性，类，注释</div><div class="line"></div><div class="line">        priority: number,//指令执行的优先级</div><div class="line"></div><div class="line">        template: string,//指令使用的模板，用HTML字符串的形式表示</div><div class="line"></div><div class="line">        templateUrl: string,//从指定的url地址加载模板</div><div class="line"></div><div class="line">        replace: bool,//是否用模板替换当前元素，若为false，则append在当前元素上</div><div class="line"></div><div class="line">        transclude: bool,//是否将当前元素的内容转移到模板中</div><div class="line"></div><div class="line">        scope: bool or object,//指定指令的作用域</div><div class="line"></div><div class="line">        controller: function controllerConstructor($scope, $element, $attrs, $transclude)&#123;...&#125;,//定义与其他指令进行交互的接口函数</div><div class="line"></div><div class="line">        require: string,//指定需要依赖的其他指令</div><div class="line"></div><div class="line">        link: function postLink(scope, iElement, iAttrs) &#123;...&#125;,//以编程的方式操作DOM，包括添加监听器等</div><div class="line"></div><div class="line">        compile: function compile(tElement, tAttrs, transclude)&#123;</div><div class="line"></div><div class="line">            return: &#123;</div><div class="line"></div><div class="line">                pre: function preLink(scope, iElement, iAttrs, controller)&#123;...&#125;,</div><div class="line">                post: function postLink(scope, iElement, iAttrs, controller)&#123;...&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;//编程的方式修改DOM模板的副本，可以返回链接函数</div><div class="line">    &#125;;</div><div class="line">    return directiveDefinitionObject;</div><div class="line">&#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>loginToolbar 指令的名字。需要注意的是：在自定义指令命名时尽量不要以ng开头，防止与系统的指令冲突。</p>
<p>factory函数，叫工厂函数，它是用来创建指令的。它只会被调用一次(类似于iOS的单例模式)：当编译器第一次匹配到相应指令的时候，在其中进行初始化的工作。调用它时使用的是 $inject， 它遵循所有依赖注入(DI)规则.</p>
<ul>
<li><p>优先级priority - 当一个DOM上有多个指令时，需要指定指令执行的顺序。 优先级就是用来在执行指令的compile函数前，先排序的。高优先级的先执行</p>
</li>
<li><p>restrict - EACM中的任意一个字母。它是用来限制指令的声明格式的。如果没有这一项。那就只允许使用属性形式的指令</p>
</li>
<li><p>模板template - 将当前的元素替换掉。 替换过程会自动将元素的属性和css类名添加到新元素上</p>
</li>
<li><p>模板地址templateUrl - 和template属性一样，这里指示的是一个模板的URL。因为模板加载是异步的，所有编译和链接都会等到加载完成后再执行</p>
</li>
<li><p>替换replace - 如果设置成true，那么页面上指令内部里面的内容会被模板替换。比如:<hello><div>这是指令内部的内容</div></hello>，hello指令内部的div内容将会被模板替换掉</p>
</li>
<li><p>transclude -  如果不想让指令内部的内容被模板替换，设置为true。</p>
</li>
</ul>
<h5 id="编译函数-Compile"><a href="#编译函数-Compile" class="headerlink" title="编译函数 Compile"></a>编译函数 Compile</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">compile: function compile(tElement, tAttrs, transclude)&#123;&#125;</div></pre></td></tr></table></figure>
<p>一般需要修改模板DOM的时候，需要用到编译函数。它接受3个参数</p>
<ol>
<li>tElement （template element ）指令所在的元素。对这个元素及其子元素进行变形之类的操作是安全的.</li>
<li>tAttrs （template attributes ) 元素上所有指令声明的属性，这些属性都是在编译函数里共享的.</li>
<li>transclude - 一个嵌入的链接函数 function(scope, cloneLinkingFn)</li>
</ol>
<blockquote>
<p>需要注意的是在编译函数里面不要进行任何DOM变形之外的操作。 DOM监听事件的注册应该在Linking函数中做，而不是Compile函数中</p>
</blockquote>
<h5 id="链接函数-Link"><a href="#链接函数-Link" class="headerlink" title="链接函数  Link"></a>链接函数  Link</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function link(scope, iElement, iAttrs, controller) &#123; ... &#125;</div></pre></td></tr></table></figure>
<p>link函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM。在模板被克隆之后执行的，也是绝大部分指令逻辑代码编写的地方</p>
<ul>
<li><p>scope - 指令需要监听的作用域</p>
</li>
<li><p>iElement （instance element） 指令所在的元素。只有在 postLink 函数中对元素的子元素进行操作才是安全的.</p>
</li>
<li><p>iAttrs (instance attributes) 实例属性，所有声明在当前元素上的属性列表，属性在所有链接函数间是共享的.</p>
</li>
<li><p>controller - 控制器实例</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后,希望对大家理解AngularJS指令能有一些帮助。详细请参考<a href="https://angularjs.org/" target="_blank" rel="external">官网</a>。如果发现文章中哪里有不对的,请及时给我发评论.谢谢!</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近在公司的项目中用到AngularJs中的指令。所谓的指令在我理解看来。就是把浏览器能够识别的标签使用语法糖包装起来。在其它地方直接调用。这样极大方便了项目的开发和维护。在&lt;a href=&quot;https://www.jucaifu.com/&quot;&gt;聚财富&lt;/a&gt;项目中对通用的组件进行抽离，封装成自定义指令。整个工程都可以复用。在项目工程中创建语义化以及高度重用的组件，对于提高代码质量有很大的帮助，也方便扩展及后期维护。目前市场上的前端框架也只有AngularJS 拥有自定义指令的功能，并且AngularJS 是目前唯一提供Web应用可复用能力的框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://chaosyuan.github.io/tags/AngularJS/"/>
    
      <category term="web" scheme="http://chaosyuan.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Grunt 浅析</title>
    <link href="http://chaosyuan.github.io/2016/02/05/2016-02-05-gruntfile-dot-js-qian-xi/"/>
    <id>http://chaosyuan.github.io/2016/02/05/2016-02-05-gruntfile-dot-js-qian-xi/</id>
    <published>2016-02-05T09:57:36.000Z</published>
    <updated>2016-08-19T02:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Grunt是什么"><a href="#Grunt是什么" class="headerlink" title="Grunt是什么"></a>Grunt是什么</h4><p>Grunt是一个基于JavaScript上的一个很强大的任务管理器(task runner)，就是用JavaScript去执行一些程序来完成一些任务。比如说验证HTML、CSS、JavaScript的语法，压缩CSS、JavaScript、图像，<a href="http://www.w3cplus.com/sassguide/" target="_blank" rel="external">Sass</a>、<a href="http://less.bootcss.com/" target="_blank" rel="external">LESS</a>和<a href="http://stylus-lang.com/" target="_blank" rel="external">Stylus</a>编译成CSS等等，这些东西很适合用Grunt来解决。</p>
<a id="more"></a>
<p>Grunt其实是一个基于NodeJS,可用于自动化构建、测试、生成文档的项目管理工具。可以在开发中提高效率、减少错误率。</p>
<p>Grunt不仅仅是构建工具，它还是任务运行器，管理每个子任务的自动化运行，它还可以做更多东西</p>
<h4 id="为什么要用Grunt"><a href="#为什么要用Grunt" class="headerlink" title="为什么要用Grunt"></a>为什么要用Grunt</h4><p>刚开始要用的时候很疑惑，为什么要用Grunt？在开发ios时候，相应的环境和配置文件配置好之后，直接Archive。很直接方便。其实前端这些都是为了自动化。对于前端项目，代码维护、打包、发布等流程变得极为繁琐，同时浪费的时间和精力也越来越多，当然人为的错误也随着流程的增加而增加了更多的出错率。为了明确模块分工，我们可以会将JavaScript、CSS代码拆解成很多个模块，它们都有独立的一个个文件，但这样一来用来页面上，增加了文件个数，同时也产生过多的Http请求，从性能的角度来考虑，不利于页面优化。所以需要合并这些JavaScript和CSS文件。尽可能的将项目中的文件进行压缩.这样一来， 都希望有一种工具能代替手工操作，能帮助整个团队在开发中能精简流程、提高效率、减少错误率。</p>
<h4 id="Grunt能做什么"><a href="#Grunt能做什么" class="headerlink" title="Grunt能做什么"></a>Grunt能做什么</h4><p>Grunt就是一个工具箱，拥有非常丰富的任务插件，可以帮助我们实现各式各样的构建目标。</p>
<ol>
<li>编译文档型：比如编译LESS、Sass、Stylus、Coffeescript等。</li>
<li>文件操作型：比如说合并、压缩JavaScript、CSS、图片等</li>
<li>质量保障型：比如<a href="http://jshint.com/" target="_blank" rel="external">JSHint</a>、<a href="https://github.com/mochajs/mocha" target="_blank" rel="external">Mocha</a>等</li>
<li>类库构建型：比如说Backbone.js、ember.js、angular.js等</li>
</ol>
<p>这些任务都依赖于Grunt提供的插件来完成的，但很多工作依旧需要在命令终端手工输入命令来完成这些操作。为此在Grunt中可以使用watch任务来实现一些监听文件改变、自动触发构建等功能。从而减少人工去每次操作任务</p>
<h4 id="Grunt安装"><a href="#Grunt安装" class="headerlink" title="Grunt安装"></a>Grunt安装</h4><p>正常运行Grunt，必须先安装<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a>和<a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a></p>
<p>环境安装完成之后，终端输入命令安装grunt运行工具</p>
<pre><code>sudo  npm install -g grunt-cli
</code></pre><p>这条命令将会把grunt命令植入到系统路径中，这样就允许从任意目录来运行它(定位到任意目录运行grunt命令)</p>
<p>项目还有两个文件特别重要：<strong>package.json</strong>和<strong>Gruntfile.js</strong>，前者用于Nodejs包管理，比如Grunt插件安装，后者是Grunt配置文件，配置任务或者自定义任务</p>
<ol>
<li>package.json:用来存储已经作为npm模块发布的依赖模块。文件中列出项目所依赖的Grunt(配置Grunt版本)和Grunt插件(相应版本的插件)</li>
<li>Gruntfile.js:用于配置或者定义Grunt任务和加载Grunt插件</li>
</ol>
<p>需要注意的是这两个文件都放置在项目的根目录中，并且应该与项目的源代码一起提交。</p>
<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><p>package.json是一个JSON文件，创建这个文件的方式有很多种。比如：</p>
<ol>
<li>根据 <a href="http://www.gruntjs.net/project-scaffolding" target="_blank" rel="external">grunt-init</a> 模版自动创建特定于项目的package.json文件</li>
<li>从<a href="http://gruntjs.com/" target="_blank" rel="external">官网</a>上复制或者下载一个.</li>
<li><a href="https://docs.npmjs.com/init" target="_blank" rel="external">npm init</a>命令创建一个基本的package.json文件</li>
</ol>
<p>最简单的package.json文件模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;my-project-name&quot;,</div><div class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    //项目依赖插件</div><div class="line">    &quot;grunt&quot;: &quot;~0.4.5&quot;,</div><div class="line">    &quot;grunt-contrib-clean&quot;: &quot;^0.6.0&quot;,</div><div class="line">    &quot;grunt-contrib-compass&quot;: &quot;^1.0.0&quot;,</div><div class="line">    &quot;grunt-contrib-concat&quot;: &quot;^0.5.0&quot;,</div><div class="line">    &quot;grunt-contrib-connect&quot;: &quot;^0.9.0&quot;,</div><div class="line">    &quot;grunt-contrib-copy&quot;: &quot;^0.7.0&quot;,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>向package.json文件中添加Grunt插件最简单方式是通过命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install &lt;module&gt; --save-dev</div></pre></td></tr></table></figure>
<p>这条命令不仅安装了<module>，还会自动将其添加到<a href="https://docs.npmjs.com/files/package.json#devdependencies" target="_blank" rel="external">devDependencies</a> 配置段中，遵循<a href="https://docs.npmjs.com/misc/semver#Ranges" target="_blank" rel="external">tilde version range</a>格式。<br>例如：</module></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install grunt-google-cdn --save-dev</div></pre></td></tr></table></figure>
<h5 id="Gruntfile-js"><a href="#Gruntfile-js" class="headerlink" title="Gruntfile.js"></a>Gruntfile.js</h5><p>在项目根目录下使用<a href="https://github.com/gruntjs/grunt-init-gruntfile" target="_blank" rel="external">grunt-init</a>或者直接创建一个Gruntfile.js文件。</p>
<p>Gruntfile.js文件模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">module.exports = function(grunt) &#123;</div><div class="line"></div><div class="line">  // Project configuration.</div><div class="line">  grunt.initConfig(&#123;</div><div class="line">    pkg: grunt.file.readJSON(&apos;package.json&apos;),</div><div class="line">        uglify: &#123;</div><div class="line">        //uglify任务的配置信息</div><div class="line">            options: &#123;</div><div class="line">                beautify: false,</div><div class="line">                mangle: true //混淆变量名</div><div class="line">            &#125;,</div><div class="line">            dist: &#123;</div><div class="line">                files: [&#123;&#125;]</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  // 加载包含 &quot;uglify&quot; 任务的插件。</div><div class="line">  grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</div><div class="line"></div><div class="line">  // 默认被执行的任务列表。</div><div class="line">  grunt.registerTask(&apos;default&apos;, [&apos;uglify&apos;]);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>配置完成后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo  npm install</div></pre></td></tr></table></figure>
<p>具体配置任务请参考<a href="http://www.gruntjs.net/configuring-tasks" target="_blank" rel="external">官网</a></p>
<p>参考文献：</p>
<ol>
<li><a href="http://www.gruntjs.net" target="_blank" rel="external">http://www.gruntjs.net</a></li>
<li><a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="external">https://docs.npmjs.com/files/package.json</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Grunt是什么&quot;&gt;&lt;a href=&quot;#Grunt是什么&quot; class=&quot;headerlink&quot; title=&quot;Grunt是什么&quot;&gt;&lt;/a&gt;Grunt是什么&lt;/h4&gt;&lt;p&gt;Grunt是一个基于JavaScript上的一个很强大的任务管理器(task runner)，就是用JavaScript去执行一些程序来完成一些任务。比如说验证HTML、CSS、JavaScript的语法，压缩CSS、JavaScript、图像，&lt;a href=&quot;http://www.w3cplus.com/sassguide/&quot;&gt;Sass&lt;/a&gt;、&lt;a href=&quot;http://less.bootcss.com/&quot;&gt;LESS&lt;/a&gt;和&lt;a href=&quot;http://stylus-lang.com/&quot;&gt;Stylus&lt;/a&gt;编译成CSS等等，这些东西很适合用Grunt来解决。&lt;/p&gt;
    
    </summary>
    
    
      <category term="grunt" scheme="http://chaosyuan.github.io/tags/grunt/"/>
    
      <category term="web" scheme="http://chaosyuan.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>使用Yoman构建Web工作流</title>
    <link href="http://chaosyuan.github.io/2016/02/04/2016-02-04-shi-yong-yomangou-jian-webgong-zuo-liu/"/>
    <id>http://chaosyuan.github.io/2016/02/04/2016-02-04-shi-yong-yomangou-jian-webgong-zuo-liu/</id>
    <published>2016-02-04T10:10:12.000Z</published>
    <updated>2016-08-19T02:02:52.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近公司的<a href="https://www.jucaifu.com/" target="_blank" rel="external">web</a>应用上线了，抽空总结一下项目的构建流程。项目是用<a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a>创建出来的。</p>
<h4 id="Yeoman简介"><a href="#Yeoman简介" class="headerlink" title="Yeoman简介"></a>Yeoman简介</h4><p><a href="http://yeoman.io/" target="_blank" rel="external">Yeoman</a>是Google的团队和外部贡献者团队合作开发的，它的目标是通过<a href="http://yeoman.io/" target="_blank" rel="external">Yo</a>,<a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a>和<a href="http://bower.io/" target="_blank" rel="external">Bower</a>为开发者创建一个易用Web应用的工作流，可以让网络前端开发者快速打造一个漂亮的网络应用(web applications)。</p>
<p>Yeoman的目的不仅是要为新项目建立工作流，同时还是为了解决前端开发所面临的诸多严重问题，比如各种零散的依赖关系. </p>
<a id="more"></a>
<h4 id="Yeoman的作用"><a href="#Yeoman的作用" class="headerlink" title="Yeoman的作用"></a>Yeoman的作用</h4><ol>
<li>Yo:Yeoman核心工具，构建目录结构或文件，生成项目的生产环境和编译环境.</li>
<li>bower:Web开发的包管理器，类似于npm，npm专注于nodeJs模块，而bower专注于CSS、JavaScript、图像等前端相关内容的管理。需要注意的是，Bower的运行，依赖于版本控制工具git。要想成功安装Yeoman,需先安装 Git.</li>
<li>grunt:自动化构建工具.当然也可以使用<a href="http://gulpjs.com/" target="_blank" rel="external">gulp</a></li>
</ol>
<h4 id="Yeoman的安装"><a href="#Yeoman的安装" class="headerlink" title="Yeoman的安装"></a>Yeoman的安装</h4><p>在安装Yeoman之前，需要安装： <a href="https://nodejs.org/en/" target="_blank" rel="external">NodeJS</a></p>
<pre><code>yuanweideMBP:~ yuanwei$ node -v
v5.5.0
yuanweideMBP:~ yuanwei$ npm -v
3.3.12
</code></pre><p>安装yeoman,grunt,bower,-g 安装在全局范围内，任何地方都能调用到相应命令</p>
<pre><code>sudo npm install -g yo bower grunt-cli gulp
</code></pre><p><a href="http://yeoman.io/generators/" target="_blank" rel="external">查看更多的构建程序</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir   /Users/yuanwei/yomanTest</div><div class="line">cd /Users/yuanwei/yomanTest</div><div class="line">yo</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">? &apos;Allo yuanwei! What would you like to do?</div><div class="line">  Run a generator</div><div class="line">  Karma</div><div class="line">  Webapp</div><div class="line">  ──────────────</div><div class="line">  Update your generators</div><div class="line">❯ Install a generator</div><div class="line">  Find some help</div><div class="line">  Get me out of here!</div><div class="line">  ──────────────</div></pre></td></tr></table></figure>
<p>用上下箭头选中 Install a generator.安装完成后，生成的目录结构如下：</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/yomanmulu.png" alt="enter image description here"></p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>app</p>
<blockquote>
<p>源文件的存放目录,未压缩的js,css,scss等</p>
</blockquote>
<p>bower_components</p>
<blockquote>
<p>使用bower安装的第三方组件的源代码，jquery,bootstrap,angular等</p>
</blockquote>
<p> node_modules</p>
<blockquote>
<p>grunt 需要用到的工具模块安装目录</p>
</blockquote>
<p> test</p>
<blockquote>
<p>js 单元测试存放目录</p>
</blockquote>
<p>.bowerrc</p>
<blockquote>
<p>bower的配置目录，配置了使用bower安装的第3方组件存放目录</p>
</blockquote>
<p>.editorconfig</p>
<blockquote>
<p>方便开发者在不同的编辑器和IDE之间定义和维护一致的代码风格的配置，<a href="http://editorconfig.org/" target="_blank" rel="external">详细查看</a></p>
</blockquote>
<p>.gitattributes</p>
<blockquote>
<p>git属性设置，详细查看<a href="http://git-scm.com/doc" target="_blank" rel="external">git文档</a></p>
</blockquote>
<p>.gitignore</p>
<blockquote>
<p>git提交时忽略的目录，如bower_components和node_modules等目录并不需要提交给git</p>
</blockquote>
<p>.jshintrc</p>
<blockquote>
<p>jshint的配置文件，<a href="http://jshint.com/" target="_blank" rel="external">详细查看</a></p>
</blockquote>
<p>.yo-rc.json</p>
<blockquote>
<p>yo的配置文件</p>
</blockquote>
<p>.bower.json</p>
<blockquote>
<p>bower的配置文件，根据配置安装第三方组件到bower_components文件夹下</p>
</blockquote>
<p>.Gruntfile.json</p>
<blockquote>
<p>grunt的任务配置，根据任务配置自动化处理js,css等</p>
</blockquote>
<p>.package.json</p>
<blockquote>
<p>grunt的配置文件，根据配置安装grunt的依赖组件到node_modules文件夹下</p>
</blockquote>
<h4 id="开发项目"><a href="#开发项目" class="headerlink" title="开发项目"></a>开发项目</h4><p>在实际开发时，在app文件下进行开发，Grunt已经配置了开发任务</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/grunttrack.png" alt="enter image description here"></p>
<p>执行（或者直接双击serve）</p>
<pre><code>grunt serve
</code></pre><p>执行完命令后，创建tmp文件夹，存放经过编译后的scss文件，通过g<a href="https://github.com/gruntjs/grunt-contrib-connect" target="_blank" rel="external">runt-contrib-connect</a>模拟服务器打开app/index.html，并且通过<a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank" rel="external">grunt-contrib-watch</a>监听指定文件(html,css,js等)，如果文件内容改变，则通过<a href="https://github.com/gruntjs/grunt-contrib-connect" target="_blank" rel="external">grunt-contrib-connect</a>内的<a href="https://github.com/gruntjs/grunt-contrib-watch#optionslivereload" target="_blank" rel="external">livereload</a>功能通知浏览器，实现浏览器自动刷新</p>
<p>livereload功能需要配置浏览器上的扩展  <a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank" rel="external">LiveReload</a></p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/Chrome-liveReload.png" alt="enter image description here"></p>
<p>安装完毕后，在浏览器右上方开启liveReload<br>开启图案<img src="http://7xoc8b.com1.z0.glb.clouddn.com/LiveReloadIcon.png" alt="enter image description here"><br>这样LiveReload功能才能正常使用</p>
<h4 id="开发完毕"><a href="#开发完毕" class="headerlink" title="开发完毕"></a>开发完毕</h4><p>开发完毕时，需要对开发的内容进行检测，测试，压缩合并等</p>
<pre><code>grunt default
</code></pre><p>经过压缩合并等的内容都在dist目录下</p>
<h4 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h4><p><a href="https://chrome.google.com/webstore/detail/ng-inspector-for-angularj/aadgmnobpdmgmigaicncghmmoeflnamj" target="_blank" rel="external">ng-inspector for AngularJS</a><br>方便查看页面AngularJS范围层次结构 ，以及它的控制器或指令与范围。</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/ng-inspector%20for%20AngularJS.png" alt="enter image description here"></p>
<p><a href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk" target="_blank" rel="external">AngularJS Batarang</a><br>方便调试AngularJS<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/AngularJS%20Batarang.png" alt="enter image description here"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近公司的&lt;a href=&quot;https://www.jucaifu.com/&quot;&gt;web&lt;/a&gt;应用上线了，抽空总结一下项目的构建流程。项目是用&lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt;创建出来的。&lt;/p&gt;
&lt;h4 id=&quot;Yeoman简介&quot;&gt;&lt;a href=&quot;#Yeoman简介&quot; class=&quot;headerlink&quot; title=&quot;Yeoman简介&quot;&gt;&lt;/a&gt;Yeoman简介&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt;是Google的团队和外部贡献者团队合作开发的，它的目标是通过&lt;a href=&quot;http://yeoman.io/&quot;&gt;Yo&lt;/a&gt;,&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;和&lt;a href=&quot;http://bower.io/&quot;&gt;Bower&lt;/a&gt;为开发者创建一个易用Web应用的工作流，可以让网络前端开发者快速打造一个漂亮的网络应用(web applications)。&lt;/p&gt;
&lt;p&gt;Yeoman的目的不仅是要为新项目建立工作流，同时还是为了解决前端开发所面临的诸多严重问题，比如各种零散的依赖关系. &lt;/p&gt;
    
    </summary>
    
    
      <category term="Yeoman" scheme="http://chaosyuan.github.io/tags/Yeoman/"/>
    
      <category term="grunt" scheme="http://chaosyuan.github.io/tags/grunt/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS Controller 之间通信机制</title>
    <link href="http://chaosyuan.github.io/2016/01/06/2016-01-06-angularjs-controller-zhi-jian-tong-xin-ji-zhi/"/>
    <id>http://chaosyuan.github.io/2016/01/06/2016-01-06-angularjs-controller-zhi-jian-tong-xin-ji-zhi/</id>
    <published>2016-01-06T03:44:17.000Z</published>
    <updated>2016-08-19T02:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近，使用angularJS框架开发聚财富后台管理系统时，需要按照业务需求区分controller。有时候不同controller之间需要进行通信。在项目之初的时候，也踩过几次坑。所以总结一下controller之间通信方式。</p>
<a id="more"></a>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p> 在Angularjs中controller是个函数，用来向视图的作用域（$scope）添加额外的功能，一般用它来给作用域对象设置初始状态，并添加自定义行为。</p>
<p> 在创建新的控制器时，angularJS会生成并传递一个新的\$scope对象给这个controller,在angularJS应用的中的任何一个部分，都有父级作用域的存在，顶级就是ng-app所在的层级，它的父级作用域就是\$rootScope.每个\$scope的\$root指向\$rootScope.</p>
<p>cotroller之间的通信本质上是当前的controller所在的\$scope如何跟其它controller上的\$scope进行通信。</p>
<p>控制器通信的方式有3种：</p>
<blockquote>
<ol>
<li>利用作用域继承的方式。即子控制器继承父控制器中的内容.</li>
<li>使用angularJS中的事件，也就是使用\$on,\$emit,$broadcast进行消息传递.</li>
<li>使用angularJS中的服务.写一个服务单例然后通过注入(DI)来使用</li>
</ol>
</blockquote>
<h4 id="作用域继承"><a href="#作用域继承" class="headerlink" title="作用域继承"></a>作用域继承</h4><p>由于作用域的继承是基于js的原型继承方式，分为两种情况（值类型和引用类型）.</p>
<ul>
<li>当作用域上面的值为基本类型的时候，修改父作用域上面的值会影响到子作用域，反之，修改子作用域只会影响子作用域的值，不会影响父作用域上面的值.</li>
<li>当作用域上的值为对象，任何一方的修改都能影响另一方，这是在js中对象都是引用类型.</li>
</ul>
<p>angularJS中默认情况下，当前作用域中无法找到某个属性时，就会在父级作用域中进行查找，若找不到直至查找到\$rootScope。 如果在\$rootScope中也无法找到程序依旧运行，但视图不会更新.</p>
<p><strong>基本类型</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function fatherCtr($scope) &#123;</div><div class="line">      $scope.location = &quot;Mos Eisley North&quot;;</div><div class="line">      $scope.move = function(newLocation) &#123;</div><div class="line">           $scope.location = newLocation;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function sonCtr($scope) &#123;</div><div class="line">      $scope.sell = function(newLocation) &#123;</div><div class="line">         $scope.location = newLocation;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller=&quot;fatherCtr&quot;&gt;</div><div class="line">    &lt;p&gt;Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;button ng-click=&quot;move(&apos;Mos Eisley South&apos;)&quot;&gt;Move&lt;/button&gt;</div><div class="line">    &lt;div ng-controller=&quot;sonCtr&quot;&gt;</div><div class="line">        &lt;p&gt;Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">        &lt;button ng-click=&quot;sell(&apos;Owen Farm&apos;)&quot;&gt;Sell&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><strong>对象</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function fatherCtr($scope) &#123;</div><div class="line">    $scope.obj = &#123;location:&quot;Mos Eisley North&quot;&#125;;</div><div class="line">&#125;</div><div class="line">function sonCtr($scope) &#123;</div><div class="line">    $scope.summon = function(newLocation) &#123;</div><div class="line">        $scope.obj.location = newLocation;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller=&quot;fatherCtr&quot;&gt;</div><div class="line">    &lt;p&gt;Sandcrawler Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;div ng-controller=&quot;sonCtr&quot;&gt;</div><div class="line">        &lt;button ng-click=&quot;summon(&apos;Owen Farm&apos;)&quot;&gt;</div><div class="line">            Summon Sandcrawler</div><div class="line">        &lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h4 id="基于事件"><a href="#基于事件" class="headerlink" title="基于事件"></a>基于事件</h4><p>基于事件的方式中需要用\$on,\$emit,\$boardcast这几个内置服务来实现，其中\$on表示事件监听，\$emit表示向父级以上的作用域触发事件，\$boardcast表示向子级以下的作用域广播事件.其实就是一个消息通知机制，这个类似于iOS中消息中心(NSNotificationCenter).<br>原理是一样的</p>
<p><strong>向上传播事件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function fatherCtr($scope) &#123;</div><div class="line">    $scope.location = &quot;Mos Eisley North&quot;;</div><div class="line">    $scope.$on(&apos;summon&apos;, function(e, newLocation) &#123;</div><div class="line">        $scope.location = newLocation;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">function sonCtr($scope) &#123;</div><div class="line">    $scope.location = &quot;Owen Farm&quot;;</div><div class="line">    $scope.summon = function() &#123;</div><div class="line">        $scope.$emit(&apos;summon&apos;, $scope.location);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller=&quot;fatherCtr&quot;&gt;</div><div class="line">    &lt;p&gt;Sandcrawler Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;div ng-controller=&quot;sonCtr&quot;&gt;</div><div class="line">        &lt;p&gt;Droid Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">        &lt;button ng-click=&quot;summon()&quot;&gt;Summon Sandcrawler&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><strong>向下广播事件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function fatherCtr($scope) &#123;</div><div class="line">    $scope.location = &quot;Mos Eisley North&quot;;</div><div class="line">    $scope.recall = function() &#123;</div><div class="line">        $scope.$broadcast(&apos;recall&apos;, $scope.location);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function sonCtr($scope) &#123;</div><div class="line">    $scope.location = &quot;Owen Farm&quot;;</div><div class="line">    $scope.$on(&apos;recall&apos;, function(e, newLocation) &#123;</div><div class="line">        $scope.location = newLocation;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">//html</div><div class="line">&lt;div ng-controller=&quot;fatherCtr&quot;&gt;</div><div class="line">    &lt;p&gt;Sandcrawler Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;button ng-click=&quot;recall()&quot;&gt;Recall Droids&lt;/button&gt;</div><div class="line">    &lt;div ng-controller=&quot;sonCtr&quot;&gt;</div><div class="line">        &lt;p&gt;Droid Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><strong>同级作用域之间传播</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">   function fatherCtr($scope) &#123;</div><div class="line">    $scope.$on(&apos;requestDroidRecall&apos;, function(e) &#123;</div><div class="line">        $scope.$broadcast(&apos;executeDroidRecall&apos;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">function sonCtr($scope) &#123;</div><div class="line">    $scope.location = &quot;Owen Farm&quot;;</div><div class="line">    $scope.recallAllDroids = function() &#123;</div><div class="line">        $scope.$emit(&apos;requestDroidRecall&apos;);</div><div class="line">    &#125;</div><div class="line">    $scope.$on(&apos;executeDroidRecall&apos;, function() &#123; </div><div class="line">        $scope.location = &quot;Sandcrawler&quot;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">// html</div><div class="line">&lt;div ng-controller=&quot;fatherCtr&quot;&gt;</div><div class="line">    &lt;div ng-controller=&quot;sonCtr&quot;&gt;</div><div class="line">        &lt;h2&gt;R2-D2&lt;/h2&gt;</div><div class="line">        &lt;p&gt;Droid Location: &#123;&#123;location&#125;&#125;&lt;/p&gt;</div><div class="line">        &lt;button ng-click=&quot;recallAddDroids()&quot;&gt;Recall All Droids&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div ng-controller=&quot;sonCtr&quot;&gt;</div><div class="line">        &lt;h2&gt;C-3PO&lt;/h2&gt;</div><div class="line">        &lt;p&gt;Droid Location: &#123;&#123;status&#125;&#125;&lt;/p&gt;</div><div class="line">        &lt;button ng-click=&quot;recallAddDroids()&quot;&gt;Recall All Droids&lt;/button&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h4 id="基于服务"><a href="#基于服务" class="headerlink" title="基于服务"></a>基于服务</h4><p>利用angularJS中service单例模式的，服务(service)提供了一种能在应用的整个生命周期内保持数据的方式，能够在控制器之间进行通信，且能保证数据的一致性。(这个类似于iOS中的单例模式，在应用程序结束之前，不会被释放).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  &apos;use strict&apos;;</div><div class="line">  </div><div class="line">  var msModule = angular.module(&apos;front_end_config&apos;, [&apos;resource.frontEndConfig&apos;,&apos;jcfApiResource&apos;]);</div><div class="line">  msModule.factory(&apos;msInstance&apos;, function()&#123;</div><div class="line">    return &#123;&#125;;</div><div class="line">  &#125;);</div><div class="line">  msModule.controller(&apos;SmsController&apos;, function($scope, msInstance) &#123;</div><div class="line">    $scope.editSms = function (row) &#123;</div><div class="line">      msInstance.editRow = row;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">  msModule.controller(&apos;smsInfoController&apos;, function($scope, msInstance) &#123;</div><div class="line">    $scope.smsInfo = function() &#123;</div><div class="line">      $scope.smsInfoRow =  msInstance.editRow;</div><div class="line">    &#125;;</div><div class="line">  &#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="http://stackoverflow.com/questions/11252780/whats-the-correct-way-to-communicate-between-controllers-in-angularjs/19498009#19498009" target="_blank" rel="external">whats the correct way to conmmunicate between controllers</a></li>
<li><a href="http://www.angularjs.cn/A07b" target="_blank" rel="external">http://www.angularjs.cn/A07b</a></li>
<li><a href="http://www.cnblogs.com/whitewolf/archive/2013/04/16/3024843.html" target="_blank" rel="external">Angularjs Controller 间通信机制</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;最近，使用angularJS框架开发聚财富后台管理系统时，需要按照业务需求区分controller。有时候不同controller之间需要进行通信。在项目之初的时候，也踩过几次坑。所以总结一下controller之间通信方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://chaosyuan.github.io/tags/AngularJS/"/>
    
      <category term="Web" scheme="http://chaosyuan.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS Promise对象($q)</title>
    <link href="http://chaosyuan.github.io/2015/12/10/2015-12-10-angularjs-promisedui-xiang-$q/"/>
    <id>http://chaosyuan.github.io/2015/12/10/2015-12-10-angularjs-promisedui-xiang-$q/</id>
    <published>2015-12-10T03:38:10.000Z</published>
    <updated>2016-08-19T02:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><p>promise是一种编程模式，以同步操作的流程形式来操作异步事件，避免了层层嵌套，可以链式操作异步事件。<br>在编写javascript异步代码时，callback是最最简单的机制，可是用这种机制控制流程、异常处理等比较麻烦，影响到代码的可读性甚至是代码质量，而promise解决了这个问题。</p>
<a id="more"></a>
<h4 id="q"><a href="#q" class="headerlink" title="$q"></a>$q</h4><p>在javaScript中有个广泛流行的库<a href="https://github.com/kriskowal/q" target="_blank" rel="external">Q</a>，angular中的$q就是从它引入的.<br>$q是做为angularjs的一个内置服务而存在的，只是对promise异步编程模式的一个简化实现版.</p>
<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>defer对象(延迟对象)可以通$q.defer( )获取，下面是defer对象的api：</p>
<ol>
<li>resolve(value):向promise对象发送消息成功完成任务，value即为发送的消息。</li>
<li>reject(reason): 向promise对象发送消息已经不可能完成这个任务了(拒绝)，reason即为发送的消息（拒绝原因）。</li>
<li>notify(value): 向promise对象发送消息现在任务完成的情况（通知），value即为发送的消息。</li>
<li>all( ) 传入Promise的数组，批量执行，返回一个promise对象</li>
<li>when( ) 传入一个不确定的参数，如果符合Promise标准，就返回一个promise对象</li>
</ol>
<p>关于状态有几个规定：</p>
<ol>
<li>状态的变更是不可逆的</li>
<li>等待状态可以变成完成或者拒绝</li>
</ol>
<h5 id="promise-对象的方法"><a href="#promise-对象的方法" class="headerlink" title="promise 对象的方法"></a>promise 对象的方法</h5><p>promise就是这个defer对象的承诺对象，defer主要是用来发送消息的。promise对象可以通过defer.promise获取,消息发送完promise会调用现有的回调函数.</p>
<pre><code>function getUserOrderList(){
  var model = $q.defer();
    Users.userOrderList.then(function(success){
    model.resolve(success);
  },function(error){
    model.reject(error);
  });
  return model.promise;
}
</code></pre><p>then(successCallback,errorCallback,notifyCallback):参数为不同消息下的不同回调函数，defer发送不同的消息执行不同的回调函数，消息作为这些回调函数的参数传递。返回值为回一个promise对象,为支持链式调用而存在。就是一种对执行结果不确定的一种预先定义，如果成功，就执行successCallback；如果失败，就执行errorCallback，就像事先给出了一些承诺。</p>
<p>all( )方法，可以把多个primise的数组合并成一个。当所有的promise执行成功后，会执行后面的回调。回调中的参数，是每个promise执行的结果。当批量的执行某些任务时，就可以使用这个方法</p>
<pre><code> var downLoadLyric = function(){
     console.log(&quot;开始下载歌词&quot;);
     return &quot;下载歌词&quot;;
};
 var downLoadSong = function(){
     console.log(&quot;开始下载伴奏&quot;);
     return &quot;下载伴奏&quot;;
};
$q.all([downLoadLyric(),downLoadSong()])
      .then(function(result){
          console.log(result);
    });
</code></pre><p>执行的结果：</p>
<pre><code>开始下载歌词
开始下载伴奏
Array [ &quot;下载歌词&quot;, &quot;下载伴奏&quot; ] 
</code></pre><p>when( )可以传入一个参数，参数可以是一个值，也可以是一个符合promise标准的外部对象。当传入的参数不确定时，可以使用这个方法</p>
<pre><code>var funcA = function(){
       console.log(&quot;funcA&quot;);
       return &quot;hello,funcA&quot;;
    };
$q.when(funcA())
     .then(function(result){
       console.log(result);
   });
</code></pre><p>   执行的结果：</p>
<pre><code>hello,funcA
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;promise&quot;&gt;&lt;a href=&quot;#promise&quot; class=&quot;headerlink&quot; title=&quot;promise&quot;&gt;&lt;/a&gt;promise&lt;/h4&gt;&lt;p&gt;promise是一种编程模式，以同步操作的流程形式来操作异步事件，避免了层层嵌套，可以链式操作异步事件。&lt;br&gt;在编写javascript异步代码时，callback是最最简单的机制，可是用这种机制控制流程、异常处理等比较麻烦，影响到代码的可读性甚至是代码质量，而promise解决了这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="AngularJS" scheme="http://chaosyuan.github.io/tags/AngularJS/"/>
    
      <category term="promise" scheme="http://chaosyuan.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS 路由机制</title>
    <link href="http://chaosyuan.github.io/2015/11/26/2015-11-26-angularjs-lu-you-ji-zhi/"/>
    <id>http://chaosyuan.github.io/2015/11/26/2015-11-26-angularjs-lu-you-ji-zhi/</id>
    <published>2015-11-26T11:55:58.000Z</published>
    <updated>2016-08-19T02:03:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言</p>
<p>在谈路由机制前先说一下现在比较流行的单页面应用，就是所谓的Single Page APP。它的主要目的有</p>
<ol>
<li>单页面应用</li>
<li>无刷新的视图切换 </li>
<li>每个页面包含不同数据</li>
</ol>
<a id="more"></a>
<p>虽然使用Javascript和Ajax可以实现上述功能，但是Ajax的一个致命缺点就是导致浏览器后退按钮失效，解决此问题有两种方法: </p>
<ol>
<li>使用hash，监听hashchange事件来进行视图切换</li>
<li>使用HTML5的history API，通过pushState()记录操作历史，监听popstate事件来进行视图切换</li>
</ol>
<p>这样便形成了通过地址栏进行导航的深度链接(deeplinking ),也就是AngularJS的路由机制。通过路由机制，一个单页应用的各个视图就可以很好的组织起来了</p>
<hr>
<p>ngRoute  VS ui-router</p>
<p>ngRoute 和 ui-router</p>
<h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><ul>
<li>两者都可以实现路由功能</li>
</ul>
<p>不同点</p>
<ol>
<li>ngroute是用AngularJS框架的核心部分。</li>
<li>ui-router是一个社区库，它是用来提高完善ngroute路由功能的</li>
</ol>
<p><a href="https://github.com/angular-ui/ui-router" target="_blank" rel="external">ui-router</a>路由器属于一个第三方模块，功能非常强大。更轻松配置项目的一个模块库，是ngRouter的升级版！它支持一切正常ngroute也可以做许多额外的功能。所以实际运用中，常选择ui-router作为路由器，而不用ngRoute。</p>
<hr>
<h4 id="ui-Router"><a href="#ui-Router" class="headerlink" title="ui-Router"></a>ui-Router</h4><p>安装方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install angular-ui-router --save</div></pre></td></tr></table></figure></p>
<p>将源文件包含到页面中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;bower_components/angular-ui-router/release/angular-ui-router.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>将ui.router作为web应用的依赖，注入到主程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">     &apos;use strict&apos;;</div><div class="line">      angular.module(&apos;jcfApp&apos;, [&apos;ui.router&apos;]);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>UI-Router可以将视图嵌套，因为它基于的是操作状态(.state)而仅非URL。当在ui-router中处理路由和状态时，开发者的重心是当前的状态是什么以及在哪一个页面里.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div  ui-view=&quot;main-content&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>为特定状态指定的模板将会放在ui-view元素中。,这就是在同一个路由下实现嵌套视图的方法。要定义一个路由，与ngRoute的方法相同：使用.config方式，但使用的不是$routeProvider而是$stateProvider</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">    &apos;use strict&apos;;</div><div class="line">    angular.module(&apos;app.account&apos;)</div><div class="line">        .config(routerConfigure);</div><div class="line">    routerConfigure.$inject = [&apos;$stateProvider&apos;, &apos;$urlRouterProvider&apos;];</div><div class="line">    function routerConfigure($stateProvider, $urlRouterProvider) &#123;</div><div class="line">        $urlRouterProvider.otherwise(&quot;/&quot;);</div><div class="line">        $stateProvider</div><div class="line">            .state(&quot;account&quot;, &#123;</div><div class="line">                url: &quot;/account/id&amp;from&quot;,</div><div class="line">                views: &#123;</div><div class="line">                    &quot;main-content&quot;: &#123;</div><div class="line">                        templateUrl: &apos;modules/account/account.tpl.html&apos;,</div><div class="line">                        controller: &quot;AccountController&quot;,</div><div class="line">                        controllerAs: &quot;vm&quot;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>设置对象上定义了一个叫account的状态。设置对象stateConfig和路由设置对象的选项是差不多的。url选项将会为应用的状态指定一个URL基于用户浏览该应用所在的状态。这样当在浏览该应用的时候便能实现深度链接的效果。URL可以有多个参数。参数可以使用$stateParams服务取到。</p>
<p>每个视图下可以设置模板 - template - HTML字符串（模板），或者是返回HTML字符串的函数 - templateUrl - HTML模板的路径（如上图代码），或者是返回HTML模板路径的函数 - templateProvider - 返回HTML字符串的函数。需要注意的是如果设置了视图选项views,该状态下的’template’,’templateUrl’<br>及’templateProvider‘，将被忽略</p>
<p>控制器<br>指定控制器，或者在路由里面创建一个作为控制器的函数。但如果没有定义模板，控制器将无效</p>
<p>when()<br>该函数接受两个参数：1.当前的路径，2.需要重定向到的路径（或者是需要在路径被访问是运行的函数）。设置重定向前需要为$urlRouterProvider设置when函数来接受一个字符串。例如：当重定向一个400路由到/error</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$urlRouterProvider.when(&apos;400&apos;, &apos;/error&apos;);</div></pre></td></tr></table></figure>
<p>Resolve<br>预载入功能，可以预先载入依赖或者数据，然后注入到控制器中。在ngRoute中resolve选项可以允许在路由到达前载入数据保证（promises）。</p>
<p>预载入选项需要一个对象，这个对象的key即要注入到控制器的依赖，value为需要被载入的factory服务。如果传入的时字符串，angular-route会试图匹配已经注册的服务。如果传入的是函数，该函数将会被注入，并且该函数返回的值便是控制器的依赖之一。如果该函数返回一个数据保证（promise），这个数据保证将在控制器被实例化前被预先载入并且数据会被注入到控制器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.state(&apos;banner-Detail&apos;, &#123;</div><div class="line">  url: &quot;/bannerDetail&quot;,</div><div class="line">  views: &#123;</div><div class="line">    &quot;main-content&quot;: &#123;</div><div class="line">      templateUrl: &quot;modules/front_end_config/app_ad/tpl/banner_detail.html&quot;,</div><div class="line">      controller: &quot;bannerDetailCtr&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  resolve: &#123;</div><div class="line">    desp: [&apos;$ocLazyLoad&apos;,</div><div class="line">      function ($ocLazyLoad) &#123;</div><div class="line">        return $ocLazyLoad.load(&apos;modules/front_end_config/app_ad/tpl/banner_detail.controller.js&apos;)</div><div class="line">      &#125;]</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>otherwise()<br>当用户访问的路径没有被定义的时候它将重定向到指定的页面。这是创建’默认‘路径的好方法。 otherwise()只接受一个参数，函数或者字符串，字符串必须为合法的url路由地址，函数则会在没有任何路径被匹配的时候被调用.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$urlRouterProvider.otherwise(&apos;/&apos;);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$urlRouterProvider.otherwise(</div><div class="line">    function($injector, $location) &#123;</div><div class="line">      $location.path(&apos;/&apos;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;在谈路由机制前先说一下现在比较流行的单页面应用，就是所谓的Single Page APP。它的主要目的有&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单页面应用&lt;/li&gt;
&lt;li&gt;无刷新的视图切换 &lt;/li&gt;
&lt;li&gt;每个页面包含不同数据&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://chaosyuan.github.io/tags/JavaScript/"/>
    
      <category term="AngularJS" scheme="http://chaosyuan.github.io/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS:Factory vs Service vs Provider</title>
    <link href="http://chaosyuan.github.io/2015/11/23/2015-11-23-angularjs-factory-vs-service-vs-provider/"/>
    <id>http://chaosyuan.github.io/2015/11/23/2015-11-23-angularjs-factory-vs-service-vs-provider/</id>
    <published>2015-11-23T12:02:38.000Z</published>
    <updated>2016-08-19T02:03:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写公司后台的管理系统，由于初试AngularJS. 所以很自然地就就把业务逻辑写在 controller 和 scope 中。在git上找到AngularJs编码规范，细读之后，回头看来，代码写的是一塌糊涂。controller中充斥着大量的业务逻辑。controller本身只充当控制器的作用，controller 只在需要的时候才会初始化，一旦不需要就会被抛弃。因此，当每次切换或刷新页面的时候，Angular 会清空当前的 controller。因此controller 里是不能保存持久化数据的。这不属于它的作用范畴。业务逻辑处理应该抽离出来放在Service层，这样代码逻辑更加简洁，后期维护和测试也更加方便.</p>
<a id="more"></a>
<h4 id="AngularJS-Service"><a href="#AngularJS-Service" class="headerlink" title="AngularJS Service"></a>AngularJS Service</h4><p>Angular 提供了3种方法来创建并注册我们自己的 Service.</p>
<blockquote>
<p>  1.Factory<br>  2.Service<br>  3.Provide</p>
</blockquote>
<h5 id="1-Factory"><a href="#1-Factory" class="headerlink" title="1.Factory()"></a>1.Factory()</h5><p>Angular里面创建service最简单的方式是使用factory()方法,用 factory 就是创建一个对象，为它添加属性，然后把这个对象返回出来。你把 service 传进 controller 之后，在 controller 里这个对象里的属性就可以通过 factory 使用了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  angular.module(<span class="string">'service.productList'</span>, [])</div><div class="line">    .factory(<span class="string">'productListProvider'</span>, productListProvider);</div><div class="line">  productListProvider.$inject = [<span class="string">'$log'</span>,<span class="string">'$http'</span>];</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">productListProvider</span> (<span class="params">$log,$http</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> service = &#123;</div><div class="line">      success: success,</div><div class="line">      error: error,</div><div class="line">      log: log,</div><div class="line">      debug: debug,</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> service;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debug</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="string">``</span><span class="string">`       </span></div><div class="line">在controller中调用</div><div class="line">`<span class="string">``</span>javascript</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  angular.module(<span class="string">'app.product'</span>)</div><div class="line">    .controller(<span class="string">'ProductController'</span>, ProductController);</div><div class="line">  ProductController.$inject = [<span class="string">'$scope'</span>, <span class="string">'$state'</span>,  <span class="string">'productListProvider'</span>];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ProductController</span>(<span class="params">$scope, $state, productListProvider</span>) </span>&#123;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">productList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> productListProvider.success();</div><div class="line">    &#125;</div><div class="line">    productList();</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p><strong>注意：需要使用.config()来配置service的时候,不能使用factory()方法</strong></p>
<h5 id="2-Service"><a href="#2-Service" class="headerlink" title="2.Service()"></a>2.Service()</h5><p>service()通过构造函数的方式创建service, 给”this”添加属性，然后 service 返回”this”。 service 传入controller ，在controller里 “this” 上的属性就可以通过 service 来使用了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  angular.module(<span class="string">'login.services'</span>)</div><div class="line">    .service(<span class="string">'login'</span>, login);</div><div class="line">  login.$inject = [<span class="string">'$scope'</span>, <span class="string">'$state'</span>]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">$scope, $state</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.userInfo = &#123;&#125;;</div><div class="line">    <span class="keyword">this</span>.setUserInfo = <span class="function"><span class="keyword">function</span> (<span class="params">useName</span>) </span>&#123;</div><div class="line"></div><div class="line">      self.userInfo[<span class="string">'name'</span>] = useName</div><div class="line">      <span class="keyword">return</span> userInfo;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>在controller中调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  angular.module(<span class="string">'app.userModule'</span>)</div><div class="line">    .controller(<span class="string">'UserInfoController'</span>, UserInfoController);</div><div class="line"></div><div class="line">  UserInfoController.$inject = [<span class="string">'$scope'</span>, <span class="string">'login'</span>];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">UserInfoController</span> (<span class="params">$scope, login</span>) </span>&#123;</div><div class="line">    login.setUserInfo();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h5 id="3-Provider"><a href="#3-Provider" class="headerlink" title="3.Provider()"></a>3.Provider()</h5><p>providers 是唯一一种你可以传进 .config() 函数的 service。当想要在 service 对象启用之前，先进行模块范围的配置，那优先考虑使用provider<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">  'use strict'</span>;</div><div class="line">  angular.module(<span class="string">'providerTestModele'</span>, [])</div><div class="line">    .config(<span class="function"><span class="keyword">function</span> (<span class="params">$stateProvider, $urlRouterProvider</span>) </span>&#123;</div><div class="line">      $urlRouterProvider.otherwise(<span class="string">"/"</span>);</div><div class="line">    &#125;)</div><div class="line">    .provider(<span class="string">'providerTest'</span>, [<span class="string">'$window'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$window</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.test = &#123;</div><div class="line">        <span class="string">"firstName"</span>: <span class="string">"yw"</span></div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">this</span>.$get = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.test;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    ]);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>1.<a href="https://www.airpair.com/angularjs/posts/top-10-mistakes-angularjs-developers-make" target="_blank" rel="external">https://www.airpair.com/angularjs/posts/top-10-mistakes-angularjs-developers-make</a><br>2.<a href="https://github.com/johnpapa/angular-styleguide/blob/master/i18n/zh-CN.md" target="_blank" rel="external">https://github.com/johnpapa/angular-styleguide/blob/master/i18n/zh-CN.md</a><br>3.<a href="http://tylermcginnis.com/angularjs-factory-vs-service-vs-provider/" target="_blank" rel="external">http://tylermcginnis.com/angularjs-factory-vs-service-vs-provider/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写公司后台的管理系统，由于初试AngularJS. 所以很自然地就就把业务逻辑写在 controller 和 scope 中。在git上找到AngularJs编码规范，细读之后，回头看来，代码写的是一塌糊涂。controller中充斥着大量的业务逻辑。controller本身只充当控制器的作用，controller 只在需要的时候才会初始化，一旦不需要就会被抛弃。因此，当每次切换或刷新页面的时候，Angular 会清空当前的 controller。因此controller 里是不能保存持久化数据的。这不属于它的作用范畴。业务逻辑处理应该抽离出来放在Service层，这样代码逻辑更加简洁，后期维护和测试也更加方便.&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://chaosyuan.github.io/tags/JavaScript/"/>
    
      <category term="AngularJS" scheme="http://chaosyuan.github.io/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移说明</title>
    <link href="http://chaosyuan.github.io/2015/11/21/2015-11-21-bo-ke-qian-yi-shuo-ming/"/>
    <id>http://chaosyuan.github.io/2015/11/21/2015-11-21-bo-ke-qian-yi-shuo-ming/</id>
    <published>2015-11-21T11:39:47.000Z</published>
    <updated>2016-08-10T03:02:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>写博客也有一段时间了，之前在CSDN上，但是总是感觉不方便。因此决定之前的博客都不再更新，统一转移到这里。 之前的一些博客我也会挑一部分贴过来。欢迎大家以后多交流。<br>原Blog地址：<a href="http://blog.csdn.net/u014466582" target="_blank" rel="external">http://blog.csdn.net/u014466582</a></p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写博客也有一段时间了，之前在CSDN上，但是总是感觉不方便。因此决定之前的博客都不再更新，统一转移到这里。 之前的一些博客我也会挑一部分贴过来。欢迎大家以后多交流。&lt;br&gt;原Blog地址：&lt;a href=&quot;http://blog.csdn.net/u014466582&quot;&gt;http://blog.csdn.net/u014466582&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSDN" scheme="http://chaosyuan.github.io/tags/CSDN/"/>
    
      <category term="iOS" scheme="http://chaosyuan.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Carthage 包管理工具</title>
    <link href="http://chaosyuan.github.io/2015/11/19/2015-11-19-carthage-bao-guan-li-gong-ju/"/>
    <id>http://chaosyuan.github.io/2015/11/19/2015-11-19-carthage-bao-guan-li-gong-ju/</id>
    <published>2015-11-19T03:52:38.000Z</published>
    <updated>2016-08-19T02:04:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>说到iOS开发的包管理，大家首先可能会想到Cocoapads,它确实是一个很强大的工具，但是这次主要说一下另外一个包管理工具Carthage.</p>
<a id="more"></a>
<p> CocoaPods 和 Carthage的区别:</p>
<p>CocoaPods 是一套整体解决方案，在 Podfile文件中指定好我们需要的第三方库。然后执行 pod update命令，就会进行下载，集成，CocoaPods默认会自动创建并更新你的应用程序和所有依赖的Xcode workspace。CocoaPods的方法非常易于使用。</p>
<p>相比之下，Carthage 就要轻量很多，它也会一个叫做 Cartfile 描述文件，但 Carthage 不会对我们的项目结构进行任何修改，更不多创建 workspace。它只是根据我们描述文件中配置的第三方库，将他们下载到本地，然后使用 xcodebuild 构建成 framework 文件。然后由我们自己将这些库集成到项目中。Carthage 使用的是一种非侵入性的方式，它本身不会对我们的项目结构进行任何改动。</p>
<p>CocoaPods为提高第三方开源库的可见性和参与度，创建一个更中心化的生态系统， CocoaPods 有一个中心服务器(cocoapods.org)，来管理各个包的元信息，依赖于每个第三方库自己的源地址，比如 Github。包管理依赖中心服务器，索引第三方库十分方便。</p>
<p>与之相比，Carthage创建的是去中心化的依赖管理器。它没有总项目的列表，这能够减少维护工作并且避免任何中心化带来的问题。不过，这样也有一些缺点，就是项目的发现将更困难，想查找第三方库的时候，也没有一个中心服务器来帮助我们进行索引，而是必须从网络上自行查找，用户将依赖于Github的趋势页面或者类似的代码库来寻找项目。此外，Carthage是用swift语言编写的，Carthage只正式支持动态框架，动态框架能够在任何版本的OS X上使用，但只能在iOS 8及以上版本使用</p>
<p>创建Carthage的原因是想要一种尽可能简单的工具——一个只关心本职工作的依赖管理器，而不是取代部分Xcode的功能，或者需要让框架作者做一些额外的工作。CocoaPods提供的一些特性很棒，但由于附加的复杂性，它们将不会被包含在Carthage当中。</p>
<p>Carthage 和 CocoaPods 各有优劣，如何选择，就要看自己的需求了。</p>
<p>安装Carthage<br>Carthage提供OS X平台的pkg安装件，你可以从Github <a href="https://github.com/Carthage/Carthage/releases" target="_blank" rel="external">https://github.com/Carthage/Carthage/releases</a></p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/CarthageSet.png" alt="enter image description here"></p>
<p>Carthage 目前最新版本是 0.10.7，下载 Carthage.pkg 包就可以，下载成功后，双击安装。</p>
<p>安装成功后，我们就可以在项目中配置 Cartfile 文件了，可以在我们项目的根目录中，使用文件编辑器，建立这个文件：</p>
<p>在Cartfile文件中，引入一个第三方库，比如强大的网络库Alamofire:<br>github “Alamofire/Alamofire” .然后保存文件，输入命令 carthage update<br>Carthage就开始抓取并使用xcodebuild构建第三方库</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/CarthageUpdate.png" alt="enter image description here"></p>
<p>update 命令执行完以后，会在项目中生成一个Carthage目录，这个目录包含两个Build目录和Checkouts目录。</p>
<p>Build中存放的是构建好的framework包:<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/Buildfile.png" alt="enter image description here"></p>
<p>Checkouts中存放的是第三方库项目源文件：<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/Checkout.ong.png" alt="enter image description here"></p>
<p>接下来，在项目设置中，进入 General 选项卡，在最下方的 Linked Frameworks and Libraries 中，将 Carthage/Build/iOS 中的 framework 文件添加到项目中：</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/linkFrameworks.png" alt="enter image description here"></p>
<p>然后在 Build Phrases 中，点击左上角的 + 号，添加一个 New Run Script Phrase:</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/runScript.png" alt="enter image description here"></p>
<p>然后在脚本区域输入：<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/userlocalBin.png" alt="enter image description here"></p>
<p>然后将 Alamofire 的路径添加到 Input Files 中:<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/SRCRooT.png" alt="enter image description here"></p>
<p>最终结果如下图：<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/resultScroot.png" alt="enter image description here"></p>
<p>添加这个 Run Script 的作用是为了让运行时能够找到这个动态库。如果不添加这个 copy-frameworks 脚本，那么项目在运行的时候会因为找不到这个动态库而在启动的时候崩溃。</p>
<p>还可以将 Carthage 所集成的第三方库生成的符号文件添加到项目中，这样在调试的时候，就可以步入第三方库内部的代码了。</p>
<p>具体步骤，还是进入 Build Phrases ，然后在右上角点击 New Copy Files Phrase，然后将 Carthage/Build/iOS 目录中的 Alamofire.framework.dSYM 符号文件拖动进来:<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/dsymFrameWork.png" alt="enter image description here"></p>
<p>在项目运行后，就可以在断点中步入 SwiftyJSON 内部的代码了。<br>这样就通过 Carthage 将 Alamofire 库顺利的集成到项目中了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到iOS开发的包管理，大家首先可能会想到Cocoapads,它确实是一个很强大的工具，但是这次主要说一下另外一个包管理工具Carthage.&lt;/p&gt;
    
    </summary>
    
    
      <category term="CocoaPods" scheme="http://chaosyuan.github.io/tags/CocoaPods/"/>
    
      <category term="Carthage" scheme="http://chaosyuan.github.io/tags/Carthage/"/>
    
  </entry>
  
</feed>
