
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>block 实现原理及内存管理 | 袁伟的技术博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="袁伟">
    

    
    <meta name="description" content="写在前面block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观。使用起来十分的方便。同时也是iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，才能从根本上避免挖坑和踩坑。
block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不">
<meta property="og:type" content="article">
<meta property="og:title" content="block 实现原理及内存管理">
<meta property="og:url" content="http://chaosyuan.github.io/2016/02/25/2016-02-25-block-nei-cun-guan-li/index.html">
<meta property="og:site_name" content="袁伟的技术博客">
<meta property="og:description" content="写在前面block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观。使用起来十分的方便。同时也是iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，才能从根本上避免挖坑和踩坑。
block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不">
<meta property="og:image" content="http://7xoc8b.com1.z0.glb.clouddn.com/nomalBlock.png">
<meta property="og:image" content="http://7xoc8b.com1.z0.glb.clouddn.com/neiCunFenPei.png">
<meta property="og:image" content="http://7xoc8b.com1.z0.glb.clouddn.com/forwardingSelfHelp.png">
<meta property="og:updated_time" content="2016-09-12T06:51:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="block 实现原理及内存管理">
<meta name="twitter:description" content="写在前面block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观。使用起来十分的方便。同时也是iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，才能从根本上避免挖坑和踩坑。
block 只是 Objective-C 对闭包的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不">
<meta name="twitter:image" content="http://7xoc8b.com1.z0.glb.clouddn.com/nomalBlock.png">

    
    <link rel="alternative" href="/atom.xml" title="袁伟的技术博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="袁伟的技术博客">袁伟的技术博客</a></h1>
				<h2 class="blog-motto">千里之行始于足下</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/tags">标签</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:chaosyuan.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/02/25/2016-02-25-block-nei-cun-guan-li/" title="block 实现原理及内存管理" itemprop="url">block 实现原理及内存管理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="袁伟" target="_blank" itemprop="author">袁伟</a>
		
  <p class="article-time">
    <time datetime="2016-02-25T11:11:14.000Z" itemprop="datePublished"> 发表于 2016-02-25</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-结构体详解"><span class="toc-number">2.</span> <span class="toc-text">block 结构体详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-block-impl"><span class="toc-number">2.1.</span> <span class="toc-text">struct __block_impl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-main-block-impl-0"><span class="toc-number">2.2.</span> <span class="toc-text">struct __main_block_impl_0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-void-main-block-func-0"><span class="toc-number">2.3.</span> <span class="toc-text">static void __main_block_func_0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-struct-main-block-desc-0"><span class="toc-number">2.4.</span> <span class="toc-text">static struct __main_block_desc_0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#最基础的-block-执行流程"><span class="toc-number">2.5.</span> <span class="toc-text">最基础的 block 执行流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-获取外部变量"><span class="toc-number">3.</span> <span class="toc-text">block 获取外部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-修改外部变量"><span class="toc-number">4.</span> <span class="toc-text">block 修改外部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-内存分配"><span class="toc-number">5.</span> <span class="toc-text">block 内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NSConcreteGlobalBlock"><span class="toc-number">5.1.</span> <span class="toc-text">_NSConcreteGlobalBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NSConcreteStackBlock"><span class="toc-number">5.2.</span> <span class="toc-text">_NSConcreteStackBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NSConcreteMallocBlock"><span class="toc-number">5.3.</span> <span class="toc-text">_NSConcreteMallocBlock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-自动拷贝和手动拷贝"><span class="toc-number">6.</span> <span class="toc-text">block 自动拷贝和手动拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjC对象的内存管理"><span class="toc-number">7.</span> <span class="toc-text">ObjC对象的内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#retain-cycle"><span class="toc-number">7.1.</span> <span class="toc-text">retain cycle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#提前释放"><span class="toc-number">7.2.</span> <span class="toc-text">提前释放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考文献"><span class="toc-number">9.</span> <span class="toc-text">参考文献</span></a></li></ol>
		
		</div>
		
		<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>block 顾名思义就是代码块，将同一逻辑的代码放在一个块，使代码更简洁紧凑，易于阅读，而且它比函数使用更方便，代码更美观。使用起来十分的方便。同时也是iOS 开发中坑最多的地方之一，因此有必要了解下 block 的实现原理，才能从根本上避免挖坑和踩坑。</p>
<p>block 只是 Objective-C 对<a href="http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html" target="_blank" rel="external">闭包</a>的实现，并不是 iOS 独有的概念，在 C++、Java 等语言也有实现闭包，只是名称不同</p>
<a id="more"></a>
<h4 id="block-结构体详解"><a href="#block-结构体详解" class="headerlink" title="block 结构体详解"></a>block 结构体详解</h4><p>将下面的 <strong>hello.m</strong> 用 clang 编译成 <strong>hello.cpp</strong> </p>
<p><strong>test.m</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/************* Objective-C 源码 *************/</div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    void (^block)() = ^&#123;</div><div class="line">        NSLog(@&quot;hello world&quot;);</div><div class="line">    &#125;;</div><div class="line">    block();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>test.cpp</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/************* 使用 clang 编译后（部分）如下 *************/</div><div class="line"></div><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__1_wj5fwdw95j99yz601c6h_ttm0000gn_T_hello_35d731_mi_0);</div><div class="line">    &#125;</div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main() &#123;</div><div class="line">    void (*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="struct-block-impl"><a href="#struct-block-impl" class="headerlink" title="struct __block_impl"></a>struct __block_impl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">struct __block_impl &#123;</div><div class="line">  void *isa;</div><div class="line">  int Flags;</div><div class="line">  int Reserved;</div><div class="line">  void *FuncPtr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><p>isa：指向对象所属的类，表明 block 本身也是一个 OC 对象。block按照内存位置，可分为三种类型：</p>
<blockquote>
<p>NSConcreteGlobalBlock  全局区block<br>NSConcreteStackBlock  栈区block<br>NSConcreteMallocBlock 堆区Block</p>
</blockquote>
</li>
<li><p>Flags：按bit位表示一些block的附加信息，比如判断block类型、判断block引用计数、判断block是否需要执行辅助函数等</p>
</li>
<li>Reserved ：保留变量</li>
<li>FuncPtr ：函数指针，指向 Block 要执行的函数（入口地址）</li>
</ul>
<h5 id="struct-main-block-impl-0"><a href="#struct-main-block-impl-0" class="headerlink" title="struct __main_block_impl_0"></a>struct __main_block_impl_0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>impl：block实现的结构体变量，该结构体上面已说明</li>
<li>Desc：描述 block 的结构体变量</li>
<li>__main_block_impl_0：结构体的构造函数。初始化 impl、Desc</li>
</ul>
<h5 id="static-void-main-block-func-0"><a href="#static-void-main-block-func-0" class="headerlink" title="static void __main_block_func_0"></a>static void __main_block_func_0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// void __main_block_func_0 是 block 最终要执行的函数</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders__1_wj5fwdw95j99yz601c6h_ttm0000gn_T_hello_35d731_mi_0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h5 id="static-struct-main-block-desc-0"><a href="#static-struct-main-block-desc-0" class="headerlink" title="static struct __main_block_desc_0"></a>static struct __main_block_desc_0</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// struct __main_block_desc_0 是对 block 进行描述的结构体</div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>reserved ：结构体信息保留字段</li>
<li>Block_size ：结构体大小<br>此处已定义了一个该结构体类型的变量 __main_block_desc_0_DATA</li>
</ul>
<h5 id="最基础的-block-执行流程"><a href="#最基础的-block-执行流程" class="headerlink" title="最基础的 block 执行流程"></a>最基础的 block 执行流程</h5><p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/nomalBlock.png" alt="最基础的 block 执行流程"></p>
<h4 id="block-获取外部变量"><a href="#block-获取外部变量" class="headerlink" title="block 获取外部变量"></a>block 获取外部变量</h4><p>运行如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">  int a = 10;</div><div class="line">  void (^block)() = ^&#123;</div><div class="line">    printf(&quot;a = %d\n&quot;, a);</div><div class="line">  &#125;;</div><div class="line">   block();</div><div class="line">   return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = 10</div></pre></td></tr></table></figure></p>
<p>和第一段源码不同的是，这里多局部变量 a，而且还在 block 里面获取到了。前面源码分析中，了解到 block 的函数定义在 main() 函数之外。那又是如何获取 main() 里面的局部变量呢? 为了弄明白，再次用 clang 重写这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  int a;</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  int a = __cself-&gt;a; // bound by copy</div><div class="line"></div><div class="line">    printf(&quot;a = %d\n&quot;, a);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;</div><div class="line">int main()&#123;</div><div class="line">  int a = 10;</div><div class="line">  void (*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</div><div class="line">   ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原来 block 通过参数值传递，获取到变量a ，通过函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _a, int flags=0) : a(_a)</div></pre></td></tr></table></figure>
<p>保存到 <strong>main_block_impl_0 结构体的同名变量 a，通过代码 int a = </strong>cself-&gt;a; 取出 a，打印出来.</p>
<p>构造函数 __main_block_impl_0 冒号后的表达式 a(_a) 的意思是，用 _a初始化结构体成员变量 a</p>
<p>这里能获取到外部变量主要是：值传递</p>
<p>如果在 block 内部修改 a 的值，会报编译错误</p>
<h4 id="block-修改外部变量"><a href="#block-修改外部变量" class="headerlink" title="block 修改外部变量"></a>block 修改外部变量</h4><p>从上面的demo代码中，可以知道在block中可以读取外部的局部变量，但是没有写操作权限，也就是写操作无效。在 C 语言中有三种类型的变量，可在 block 内进行读写操作</p>
<blockquote>
<p>全局变量<br>全局静态变量<br>静态变量</p>
</blockquote>
<p>全局变量 和 全局静态变量 由于作用域在全局，所以在 block 内访问和读写这两类变量和普通函数没什么区别,而 静态变量 作用域在 block 之外，是怎么对它进行读写呢？通过 clang ，可以发现原来 静态变量 是通过指针传递，将变量传递到 block 内，所以可以修改变量值。而上面的demo中的外部变量是通过值传递，自然没法对获取到的外部变量进行修改。由此，可以给我们一个启示，当需要修改外部变量时，是不是也可以像 静态变量 这样通过指针传递来修改外部变量的值呢？在OC中有个修饰符__block可以做到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/************* 使用 __block 修饰 *************/</div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">        __block int b = 10;</div><div class="line">        void (^block)() = ^&#123;</div><div class="line">            printf(&quot;%d\n&quot;,b);</div><div class="line">        &#125;;</div><div class="line">        b  = 20;</div><div class="line">        block();</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/************* 使用 clang 编译后（部分）如下 *************/</div><div class="line">// 存储 __block 外部变量的结构体</div><div class="line">struct __Block_byref_b_0 &#123;</div><div class="line">  void *__isa;</div><div class="line">__Block_byref_b_0 *__forwarding;</div><div class="line"> int __flags;</div><div class="line"> int __size;</div><div class="line"> int b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __main_block_impl_0 &#123;</div><div class="line">  struct __block_impl impl;</div><div class="line">  struct __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_b_0 *b; // by ref</div><div class="line">  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_b_0 *_b, int flags=0) : b(_b-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_b_0 *b = __cself-&gt;b; // bound by ref</div><div class="line"></div><div class="line">            printf(&quot;%d\n&quot;,(b-&gt;__forwarding-&gt;b));</div><div class="line">        &#125;</div><div class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;b, (void*)src-&gt;b, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;b, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</div><div class="line"></div><div class="line">static struct __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</div><div class="line">  void (*dispose)(struct __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line">int main() &#123;</div><div class="line"></div><div class="line">        __attribute__((__blocks__(byref))) __Block_byref_b_0 b = &#123;(void*)0,(__Block_byref_b_0 *)&amp;b, 0, sizeof(__Block_byref_b_0), 10&#125;;</div><div class="line">        void (*block)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_b_0 *)&amp;b, 570425344));</div><div class="line">        (b.__forwarding-&gt;b) = 20;</div><div class="line">        ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里代码量比之前增加了一些</p>
<blockquote>
<p> <strong>_struct __Block_byref_b_0</strong> 结构体：用于封装 __block 修饰的外部变量<br> <strong>_Block_object_assign</strong> 函数：当block从栈拷贝到堆时，调用此函数<br> <strong>_Block_object_dispose</strong> 函数：当 block 从堆内存释放时，调用此函数</p>
</blockquote>
<p>从代码中可以看出 <strong>__block b</strong> 翻译后变成了 <strong>__Block_byref_b_0</strong>  结构体指针，通过指针传递到 block 内，这与前面说的 静态变量 的指针传递是一致的。也就是说对于用_block修饰的外部变量引用，block是复制其引用地址来实现访问的。除此之外，整体的执行流程与不加 <strong>block 基本一致。但 **</strong>Block_byref_b_0** 这个结构体需特别注意下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 存储 __block 外部变量的结构体</div><div class="line">struct __Block_byref_b_0 &#123;</div><div class="line">  void *__isa; // 对象指针</div><div class="line">__Block_byref_b_0 *__forwarding; // 指向自己的指针</div><div class="line"> int __flags; // 标志位变量</div><div class="line"> int __size; // 结构体大小</div><div class="line"> int b; // 外部变量</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>对于__forwarding这个指针，刚开始完全不知道它是干啥用的？在google后才知道它的用处，后面会详细介绍。</p>
<p>对于__block 修饰的变量，block的处理方法是copy其指针，在内部进行retain使其引用计数递增保证存活。</p>
<h4 id="block-内存分配"><a href="#block-内存分配" class="headerlink" title="block 内存分配"></a>block 内存分配</h4><p>上面说了block按照内存划分可以分为3种类型: <strong>NSGlobalBlock</strong> <strong>NSStackBlock</strong>,<strong>NSMallocBlock</strong></p>
<p>说到内存划分，先来看看由C/C++/OBJC编译的程序占用内存分布的结构<br><img src="http://7xoc8b.com1.z0.glb.clouddn.com/neiCunFenPei.png" alt="内存分布的结构-图片来自于程序员说的博客"></p>
<p>注：这里所说的堆和栈与数据结构中的堆和栈不是一回事</p>
<ul>
<li><p>栈区（stack）：由系统自动分配，一般存放函数参数值、局部变量的值等。由编译器自动创建与释放。其操作方式类似于数据结构中的栈，即后进先出、先进后出的原则</p>
<blockquote>
<p>例如：在函数中申明一个局部变量int a;系统自动在栈中为a开辟空间。</p>
</blockquote>
</li>
<li><p>堆区（heap）：一般由程序员申请并指明大小，最终也由程序员释放。如果程序员不释放，程序结束时可能会由OS回收。对于堆区的管理是采用链表式管理的，操作系统有一个记录空闲内存地址的链表，当接收到程序分配内存的申请时，操作系统就会遍历该链表，遍历到一个记录的内存地址大于申请内存的链表节点，并将该节点从该链表中删除，然后将该节点记录的内存地址分配给程序</p>
</li>
<li><p>全局区/静态区：全局变量和静态变量存储在这个区域。只不过初始化的全局变量和静态变量存储在一块，未初始化的全局变量和静态变量存储在一块。程序结束后由系统释放</p>
</li>
<li>文字常量区：这个区域主要存储字符串常量。程序结束后由系统释放</li>
<li>程序代码区：这个区域主要存放函数体的二进制代码</li>
</ul>
<h5 id="NSConcreteGlobalBlock"><a href="#NSConcreteGlobalBlock" class="headerlink" title="_NSConcreteGlobalBlock"></a>_NSConcreteGlobalBlock</h5><p>_NSConcreteGlobalBlock 类型的 block 处于内存的全局区，此处没有局部变量的骚扰，运行不依赖上下文，内存管理也简单的多</p>
<blockquote>
<ol>
<li>当block写在全局作用域时，即为<strong>gloal block</strong></li>
<li>当 block 不获取任何外部变量时，即为 <strong>global block</strong></li>
</ol>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line"></div><div class="line">  ^&#123; printf(&quot;hello world\n&quot;);&#125;();</div><div class="line">  return  0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="NSConcreteStackBlock"><a href="#NSConcreteStackBlock" class="headerlink" title="_NSConcreteStackBlock"></a>_NSConcreteStackBlock</h5><p>保存在栈中的block，当函数返回时被销毁,例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int a = 10;</div><div class="line">    ^&#123; printf(&quot;%d\n&quot;,a); &#125; ();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于stack block 处在内存栈区，其变量作用域结束， block 就被废弃，为了解决这个问题，block 提供了copy功能，将block 和 __block 变量从栈拷贝到堆中，也就是MallocBlock</p>
<h5 id="NSConcreteMallocBlock"><a href="#NSConcreteMallocBlock" class="headerlink" title="_NSConcreteMallocBlock"></a>_NSConcreteMallocBlock</h5><p>当 block 从栈拷贝到堆后，当栈上变量作用域结束时，仍然可以使用 block。那么此时，堆上的 block 类型为 _NSConcreteMallocBlock。例如，在exampleB_addBlockToArray方法中的block还是_NSConcreteStackBlock类型的，在exampleB方法中就被复制到了堆中，成为_NSConcreteMallocBlock类型的block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void exampleB_addBlockToArray(NSMutableArray *array) &#123;</div><div class="line">    int a = 10;</div><div class="line">    [array addObject:^&#123;</div><div class="line">            printf(&quot;%d\n&quot;, a);</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void exampleB() &#123;</div><div class="line">    NSMutableArray *array = [NSMutableArray array];</div><div class="line">    exampleB_addBlockToArray(array);</div><div class="line">    void (^block)() = [array objectAtIndex:0];</div><div class="line">    block();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>__forwarding</strong></p>
<p>forwarding指针，这个指向自己的指针我疑惑了好久才明白，当 block 从栈被拷贝到堆时，__forwarding 指针变量也会指向堆区的结构体。但是为什么要这么做呢？为什么要让原本指向栈区的结构体的指针，去指向堆区的结构体呢？看起来匪夷所思，实则原因很简单。要从 __forwarding 产生的原因说起。想想起初为什么要给 block 添加 copy 的功能，就是因为 block 获取了局部变量，当要在其他地方（超出局部变量作用范围）使用这个 block 的时候，由于访问局部变量异常，导致程序崩溃。为了解决这个问题，就给 block 添加了 copy 功能。在将 block 拷贝到堆上的同时，将   __forwarding 指针指向堆上结构体。后面如果要想使用 __block 变量，只要通过 __forwarding 访问堆上变量，就不会出现程序崩溃了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">/*************** __forwarding 的作用 ***************/</div><div class="line">&#123;</div><div class="line">    __block int a = 0;</div><div class="line">    void (^blk)(void) = [^&#123;++a;&#125; copy];</div><div class="line">    ++a;</div><div class="line">    blk();</div><div class="line">    NSLog(@&quot;%d&quot;, a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印是 2。原因很简单，当栈上的 block 被拷贝到堆上时，栈上的 __forwarding 也会指向堆上的 __block 变量的结构体。</p>
<p>上面的代码中 ^{++a;} 和 ++a; 都会被转换成 ++(a.__forwarding-&gt;a);，堆上的 a 被加了两次，最后打印堆上的 a 为 2。</p>
<p>图解如下:</p>
<p><img src="http://7xoc8b.com1.z0.glb.clouddn.com/forwardingSelfHelp.png" alt="__forwarding point to heap"></p>
<h4 id="block-自动拷贝和手动拷贝"><a href="#block-自动拷贝和手动拷贝" class="headerlink" title="block 自动拷贝和手动拷贝"></a>block 自动拷贝和手动拷贝</h4><p>在开启 ARC 时，大部分情况下编译器通常会将创建在栈上的 block 自动拷贝到堆上。只有当：</p>
<blockquote>
<p>block 作为方法或函数的参数传递时，编译器不会自动调用 copy 方法；</p>
</blockquote>
<p>剩下的这几种情况调用者就不需再手动拷贝:</p>
<blockquote>
<ul>
<li>当 block 作为函数返回值返回时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 被赋值给 __strong id 类型的对象或 block 的成员变量时，编译器自动将 block 作为 _Block_copy 函数，效果等同于 block 直接调用 copy 方法；</li>
<li>当 block 作为参数被传入方法名带有 usingBlock 的 Cocoa Framework 方法或 GCD 的 API 时。这些方法会在内部对传递进来的 block 调用 copy 或 _Block_copy 拷贝</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/************ ARC下编译器自动拷贝block ************/</div><div class="line">typedef int (^blk)(int);</div><div class="line">blk func(int rate)</div><div class="line">&#123;</div><div class="line">    return ^(int count)&#123;return rate * count;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 block 获取了外部变量，所以是创建在栈上，当 func 函数返回给调用者时，脱离了局部变量 rate 的作用范围，如果调用者使用这个 block 就会出问题。那 ARC 开启的情况呢？运行这个 block 一切正常。和预期结果不一样，ARC 到底给 block 做了什么？将上面的代码翻译下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">blk func(int rate)</div><div class="line">&#123;</div><div class="line">    blk_t tmp = &amp;__func_block_impl_0(__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);</div><div class="line">    tmp = objc_retainBlock(tmp);</div><div class="line">    return objc_autoreleaseReturnValue(tmp); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>换后出现两个新函数 objc_retainBlock、objc_autoreleaseReturnValue。关于runtime 库，具体<a href="http://opensource.apple.com/tarballs/objc4/objc4-493.9.tar.gz" target="_blank" rel="external">下载查看</a></p>
<p>由于 block 是创建在栈内存，通过 objc_retainBlock() 函数拷贝到堆内存，让 tmp 重新指向堆上的 block，然后将 tmp 所指的堆上的 block 作为一个 Objective-C 对象放入 autoreleasepool 里面，从而保证了返回后的 block 仍然可以正确执行</p>
<h4 id="ObjC对象的内存管理"><a href="#ObjC对象的内存管理" class="headerlink" title="ObjC对象的内存管理"></a>ObjC对象的内存管理</h4><p>说到block内存管理，出现问题最多的还是循环引用。objc对象，不同于基本类型，block会引起对象的引用计数变化。</p>
<p>代码如下（MRC环境）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">@interface chatModel : NSObject</div><div class="line">&#123;</div><div class="line">    NSObject *_instanceObj;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">@implementation chatModel</div><div class="line">NSObject* _globalObj = nil;</div><div class="line"></div><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        _instanceObj = [[NSObject alloc] init];</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)test&#123;</div><div class="line">    static NSObject *_staticObj = nil;</div><div class="line">    _staticObj = [[NSObject alloc] init];</div><div class="line">    _globalObj = [[NSObject alloc] init];</div><div class="line">    </div><div class="line">    NSObject *localobj = [[NSObject alloc] init];</div><div class="line">    __block NSObject *blockObj = [[NSObject alloc] init];</div><div class="line">    </div><div class="line">    typedef void(^chatBlock)(void);</div><div class="line">    </div><div class="line">    chatBlock block = ^&#123;</div><div class="line">        NSLog(@&quot;%@&quot;,_globalObj);</div><div class="line">        NSLog(@&quot;%@&quot;,_staticObj);</div><div class="line">        NSLog(@&quot;%@&quot;,_instanceObj);</div><div class="line">        NSLog(@&quot;%@&quot;,localobj);</div><div class="line">        NSLog(@&quot;%@&quot;,blockObj);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    block = [[block copy] autorelease];</div><div class="line">    block();</div><div class="line">    </div><div class="line">    NSLog(@&quot;%ld&quot;, [_globalObj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [_staticObj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [_instanceObj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [localobj retainCount]);</div><div class="line">    NSLog(@&quot;%ld&quot;, [blockObj retainCount]);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        chatModel *chatObj = [[[chatModel alloc] init] autorelease];</div><div class="line">        [chatObj test];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果：1 1 1 2 1</p>
<blockquote>
<ul>
<li>_globalObj和_staticObj在内存中的全局区，位置是确定的，所以Block copy时不会retain对象</li>
<li>_instanceObj在Block copy时也没有直接retain _instanceObj对象本身，但会retain self。所以在Block中可以直接读写_instanceObj变量</li>
<li>localObj在Block copy时，系统自动retain对象，增加其引用计数</li>
<li>blockObj在Block copy时也不会retain</li>
</ul>
</blockquote>
<p>非ObjC对象，如GCD队列dispatch_queue_t。Block copy时并不会自动增加他的引用计数</p>
<p>注意：blockObj的<strong>block修饰符去除后，引用计数会加+1.说明没有 \</strong>block 修饰符的对象类型的变量则会被 retian.</p>
<p>在 MRC 下，使用 __block 修饰符也可以避免循环引用。因为当 block 从栈拷贝到堆时，__block 对象类型的变量不会被 retain，没有 __block 修饰符的对象类型的变量则会被 retian。正是由于 __block 在 ARC 和 MRC 下的巨大差异，在写代码时一定要区分清楚到底是 ARC 还是 MRC.</p>
<blockquote>
<p>尽管 ARC 已经如此普及，可能已经可以不用去管 MRC 的东西，但要有点一定要明白，ARC 和 MRC 都是基于引用计数的内存管理，其本质上是一个东西，只不过 ARC 在编译期自动化的做了内存引用计数的管理，使得系统可以在适当的时候保留内存，适当的时候释放内存</p>
</blockquote>
<p>如下代码（ARC）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic,copy)  void (^blk)();</div><div class="line"></div><div class="line">chatModel *obj = [[chatModel alloc] init];</div><div class="line">    self.blk = ^&#123;</div><div class="line">        NSLog(@&quot;%@&quot;,obj);</div><div class="line">    &#125;;</div><div class="line">  NSLog(@&quot;%@&quot;,[obj valueForKey:@&quot;retainCount&quot;]);</div></pre></td></tr></table></figure></p>
<p>打印结果：3<br>对象obj在Block被copy到堆上的时候自动retain了一次。因为Block不知道obj什么时候被释放，为了不在Block使用obj前被释放，Block retain了obj一次，在Block被释放的时候，obj被release一次</p>
<h5 id="retain-cycle"><a href="#retain-cycle" class="headerlink" title="retain cycle"></a>retain cycle</h5><p>retain cycle问题的根源在于Block和obj可能会互相强引用，互相retain对方，这样就导致了retain cycle，最后这个Block和obj就变成了闭环，谁也释放不了谁。</p>
<p>解决循环引用的关键在于：解除这个闭环，在实现开发工作中，一般处理的方式是使用弱引用 例如：<code>typeof(self) __weak weakSelf = self</code>或者手动将其中的一方置为nil。这个就不多说了</p>
<h5 id="提前释放"><a href="#提前释放" class="headerlink" title="提前释放"></a>提前释放</h5><p>如下面的例子，如果不只是request持有了Block，另一个对象也持有了Block</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     +-----------+           +-----------+</div><div class="line">     | request   |           |   Block   |   objA</div><div class="line">----&gt;|           | --------&gt; |           |&lt;--------</div><div class="line">     | retain 1  | &lt; - - - - | retain 2  |</div><div class="line">     |           |   weak    |           |</div><div class="line">     +-----------+           +-----------+</div></pre></td></tr></table></figure>
<p>这时如果request 被持有者释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     +-----------+           +-----------+</div><div class="line">     | request   |           |   Block   |   objA</div><div class="line">--X-&gt;|           | --------&gt; |           |&lt;--------</div><div class="line">     | retain 0  | &lt; - - - - | retain 1  |</div><div class="line">     |           |   weak    |           |</div><div class="line">     +-----------+           +-----------+</div></pre></td></tr></table></figure>
<p>这时request已被完全释放，但Block仍被objA持有，没有释放，如果这时触发了Block，在Block中将访问已经销毁的request，这将导致程序crash。为了避免这种情况，所以开发时必须要注意对象和Block的生命周期</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上是个人的实践和理解，如果有不正确的地方，欢迎批评指正。</p>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol>
<li><a href="http://blog.csdn.net/jasonblog/article/details/7756763" target="_blank" rel="external">iOS中block实现的探究</a></li>
<li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></li>
<li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="external">正确使用Block避免Cycle Retain和Crash</a></li>
</ol>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/iOS/">iOS</a><a href="/tags/block/">block</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://chaosyuan.github.io/2016/02/25/2016-02-25-block-nei-cun-guan-li/" data-title="block 实现原理及内存管理 | 袁伟的技术博客" data-tsina="undefined" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/03/02/2016-03-02-reactivecocoaxue-xi-zhi-lu1/" title="ReactiveCocoa学习之路（一）">
  <strong>上一篇：</strong><br/>
  <span>
  ReactiveCocoa学习之路（一）</span>
</a>
</div>


<div class="next">
<a href="/2016/02/16/2016-02-16-angularjs-zhi-ling-xiang-jie/"  title="AngularJS 指令详解">
 <strong>下一篇：</strong><br/> 
 <span>AngularJS 指令详解
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2016/02/25/2016-02-25-block-nei-cun-guan-li/" data-title="block 实现原理及内存管理" data-url="http://chaosyuan.github.io/2016/02/25/2016-02-25-block-nei-cun-guan-li/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#写在前面"><span class="toc-number">1.</span> <span class="toc-text">写在前面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-结构体详解"><span class="toc-number">2.</span> <span class="toc-text">block 结构体详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-block-impl"><span class="toc-number">2.1.</span> <span class="toc-text">struct __block_impl</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-main-block-impl-0"><span class="toc-number">2.2.</span> <span class="toc-text">struct __main_block_impl_0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-void-main-block-func-0"><span class="toc-number">2.3.</span> <span class="toc-text">static void __main_block_func_0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#static-struct-main-block-desc-0"><span class="toc-number">2.4.</span> <span class="toc-text">static struct __main_block_desc_0</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#最基础的-block-执行流程"><span class="toc-number">2.5.</span> <span class="toc-text">最基础的 block 执行流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-获取外部变量"><span class="toc-number">3.</span> <span class="toc-text">block 获取外部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-修改外部变量"><span class="toc-number">4.</span> <span class="toc-text">block 修改外部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-内存分配"><span class="toc-number">5.</span> <span class="toc-text">block 内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#NSConcreteGlobalBlock"><span class="toc-number">5.1.</span> <span class="toc-text">_NSConcreteGlobalBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NSConcreteStackBlock"><span class="toc-number">5.2.</span> <span class="toc-text">_NSConcreteStackBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NSConcreteMallocBlock"><span class="toc-number">5.3.</span> <span class="toc-text">_NSConcreteMallocBlock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block-自动拷贝和手动拷贝"><span class="toc-number">6.</span> <span class="toc-text">block 自动拷贝和手动拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjC对象的内存管理"><span class="toc-number">7.</span> <span class="toc-text">ObjC对象的内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#retain-cycle"><span class="toc-number">7.1.</span> <span class="toc-text">retain cycle</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#提前释放"><span class="toc-number">7.2.</span> <span class="toc-text">提前释放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考文献"><span class="toc-number">9.</span> <span class="toc-text">参考文献</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="github-card">
<p class="asidetitle">Github 名片</p>
<div class="github-card" data-github="chaosyuan" data-width="220" data-height="119" data-theme="medium">
<script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js" ></script>
</div>
  </div>



  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/iOS/" title="iOS">iOS<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/AngularJS/" title="AngularJS">AngularJS<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/web/" title="web">web<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/grunt/" title="grunt">grunt<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ReactiveCocoa/" title="ReactiveCocoa">ReactiveCocoa<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/动画/" title="动画">动画<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/UI/" title="UI">UI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Carthage/" title="Carthage">Carthage<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Yeoman/" title="Yeoman">Yeoman<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/CSDN/" title="CSDN">CSDN<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/CocoaPods/" title="CocoaPods">CocoaPods<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/block/" title="block">block<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/promise/" title="promise">promise<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Web/" title="Web">Web<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Webpack/" title="Webpack">Webpack<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://onevcat.com/" target="_blank" title="瞄神">瞄神</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.devtang.com/" target="_blank" title="巧叔">巧叔</a>
            
          </li>
        
          <li>
            
            	<a href="https://objccn.io/" target="_blank" title="ObjC中国">ObjC中国</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.sunnyxx.com/" target="_blank" title="sunnyxx">sunnyxx</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.ibireme.com/" target="_blank" title="ibireme">ibireme</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.jucaifu.com/" target="_blank" title="聚财富">聚财富</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.51tzgl.com/" target="_blank" title="51投资攻略">51投资攻略</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.haochang.tv/" target="_blank" title="好唱">好唱</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 做人做事,只有偏执到癫狂,才能达到顶峰 <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/u/5508924750?is_all=1" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/chaosyuan" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/yuanw-92" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="袁伟">袁伟</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"chaosyuan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
